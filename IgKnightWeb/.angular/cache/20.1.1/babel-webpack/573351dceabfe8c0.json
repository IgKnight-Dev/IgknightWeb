{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n  const result = [];\n  const seen = new ExtensionIdentifierSet();\n  // (1) add all document formatter\n  const docFormatter = documentFormattingEditProvider.ordered(model);\n  for (const formatter of docFormatter) {\n    result.push(formatter);\n    if (formatter.extensionId) {\n      seen.add(formatter.extensionId);\n    }\n  }\n  // (2) add all range formatter as document formatter (unless the same extension already did that)\n  const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n  for (const formatter of rangeFormatter) {\n    if (formatter.extensionId) {\n      if (seen.has(formatter.extensionId)) {\n        continue;\n      }\n      seen.add(formatter.extensionId);\n    }\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n      provideDocumentFormattingEdits(model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n    });\n  }\n  return result;\n}\nexport class FormattingConflicts {\n  static #_ = this._selectors = new LinkedList();\n  static setFormatterSelector(selector) {\n    const remove = FormattingConflicts._selectors.unshift(selector);\n    return {\n      dispose: remove\n    };\n  }\n  static select(formatter, document, mode, kind) {\n    return _asyncToGenerator(function* () {\n      if (formatter.length === 0) {\n        return undefined;\n      }\n      const selector = Iterable.first(FormattingConflicts._selectors);\n      if (selector) {\n        return yield selector(formatter, document, mode, kind);\n      }\n      return undefined;\n    })();\n  }\n}\nexport function formatDocumentRangesWithSelectedProvider(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n  return _formatDocumentRangesWithSelectedProvider.apply(this, arguments);\n}\nfunction _formatDocumentRangesWithSelectedProvider() {\n  _formatDocumentRangesWithSelectedProvider = _asyncToGenerator(function* (accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const {\n      documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry\n    } = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode, 2 /* FormattingKind.Selection */);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);\n    }\n  });\n  return _formatDocumentRangesWithSelectedProvider.apply(this, arguments);\n}\nexport function formatDocumentRangesWithProvider(_x8, _x9, _x0, _x1, _x10, _x11) {\n  return _formatDocumentRangesWithProvider.apply(this, arguments);\n}\nfunction _formatDocumentRangesWithProvider() {\n  _formatDocumentRangesWithProvider = _asyncToGenerator(function* (accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const logService = accessor.get(ILogService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    // make sure that ranges don't overlap nor touch each other\n    const ranges = [];\n    let len = 0;\n    for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n      if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n        ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n      } else {\n        len = ranges.push(range);\n      }\n    }\n    const computeEdits = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (range) {\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);\n        const result = (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n        return result;\n      });\n      return function computeEdits(_x38) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n    const hasIntersectingEdit = (a, b) => {\n      if (!a.length || !b.length) {\n        return false;\n      }\n      // quick exit if the list of ranges are completely unrelated [O(n)]\n      const mergedA = a.reduce((acc, val) => {\n        return Range.plusRange(acc, val.range);\n      }, a[0].range);\n      if (!b.some(x => {\n        return Range.intersectRanges(mergedA, x.range);\n      })) {\n        return false;\n      }\n      // fallback to a complete check [O(n^2)]\n      for (const edit of a) {\n        for (const otherEdit of b) {\n          if (Range.intersectRanges(edit.range, otherEdit.range)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const allEdits = [];\n    const rawEditsList = [];\n    try {\n      if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);\n        const result = (yield provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n        rawEditsList.push(result);\n      } else {\n        for (const range of ranges) {\n          if (cts.token.isCancellationRequested) {\n            return true;\n          }\n          rawEditsList.push(yield computeEdits(range));\n        }\n        for (let i = 0; i < ranges.length; ++i) {\n          for (let j = i + 1; j < ranges.length; ++j) {\n            if (cts.token.isCancellationRequested) {\n              return true;\n            }\n            if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n              // Merge ranges i and j into a single range, recompute the associated edits\n              const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n              const edits = yield computeEdits(mergedRange);\n              ranges.splice(j, 1);\n              ranges.splice(i, 1);\n              ranges.push(mergedRange);\n              rawEditsList.splice(j, 1);\n              rawEditsList.splice(i, 1);\n              rawEditsList.push(edits);\n              // Restart scanning\n              i = 0;\n              j = 0;\n            }\n          }\n        }\n      }\n      for (const rawEdits of rawEditsList) {\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n        const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        if (minimalEdits) {\n          allEdits.push(...minimalEdits);\n        }\n      }\n    } finally {\n      cts.dispose();\n    }\n    if (allEdits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, allEdits, true);\n      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = allEdits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], allEdits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, {\n      userGesture\n    });\n    return true;\n  });\n  return _formatDocumentRangesWithProvider.apply(this, arguments);\n}\nexport function formatDocumentWithSelectedProvider(_x12, _x13, _x14, _x15, _x16, _x17) {\n  return _formatDocumentWithSelectedProvider.apply(this, arguments);\n}\nfunction _formatDocumentWithSelectedProvider() {\n  _formatDocumentWithSelectedProvider = _asyncToGenerator(function* (accessor, editorOrModel, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    const selected = yield FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);\n    }\n  });\n  return _formatDocumentWithSelectedProvider.apply(this, arguments);\n}\nexport function formatDocumentWithProvider(_x18, _x19, _x20, _x21, _x22, _x23) {\n  return _formatDocumentWithProvider.apply(this, arguments);\n}\nfunction _formatDocumentWithProvider() {\n  _formatDocumentWithProvider = _asyncToGenerator(function* (accessor, provider, editorOrModel, mode, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    let edits;\n    try {\n      const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n      edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      if (cts.token.isCancellationRequested) {\n        return true;\n      }\n    } finally {\n      cts.dispose();\n    }\n    if (!edits || edits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n      if (mode !== 2 /* FormattingMode.Silent */) {\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n      }\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = edits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], edits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, {\n      userGesture\n    });\n    return true;\n  });\n  return _formatDocumentWithProvider.apply(this, arguments);\n}\nexport function getDocumentRangeFormattingEditsUntilResult(_x24, _x25, _x26, _x27, _x28, _x29) {\n  return _getDocumentRangeFormattingEditsUntilResult.apply(this, arguments);\n}\nfunction _getDocumentRangeFormattingEditsUntilResult() {\n  _getDocumentRangeFormattingEditsUntilResult = _asyncToGenerator(function* (workerService, languageFeaturesService, model, range, options, token) {\n    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n    for (const provider of providers) {\n      const rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n  return _getDocumentRangeFormattingEditsUntilResult.apply(this, arguments);\n}\nexport function getDocumentFormattingEditsUntilResult(_x30, _x31, _x32, _x33, _x34) {\n  return _getDocumentFormattingEditsUntilResult.apply(this, arguments);\n}\nfunction _getDocumentFormattingEditsUntilResult() {\n  _getDocumentFormattingEditsUntilResult = _asyncToGenerator(function* (workerService, languageFeaturesService, model, options, token) {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    for (const provider of providers) {\n      const rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n  return _getDocumentFormattingEditsUntilResult.apply(this, arguments);\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n  const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (accessor, ...args) {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n  return function (_x35) {\n    return _ref.apply(this, arguments);\n  };\n}());\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (accessor, ...args) {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n  return function (_x36) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (accessor, ...args) {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n  return function (_x37) {\n    return _ref3.apply(this, arguments);\n  };\n}());","map":{"version":3,"names":["asArray","isNonEmptyArray","CancellationToken","onUnexpectedExternalError","Iterable","LinkedList","assertType","URI","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","isCodeEditor","Position","Range","Selection","IEditorWorkerService","ITextModelService","FormattingEdit","CommandsRegistry","ExtensionIdentifierSet","IInstantiationService","ILanguageFeaturesService","ILogService","AccessibilitySignal","IAccessibilitySignalService","getRealAndSyntheticDocumentFormattersOrdered","documentFormattingEditProvider","documentRangeFormattingEditProvider","model","result","seen","docFormatter","ordered","formatter","push","extensionId","add","rangeFormatter","has","displayName","provideDocumentFormattingEdits","options","token","provideDocumentRangeFormattingEdits","getFullModelRange","FormattingConflicts","_","_selectors","setFormatterSelector","selector","remove","unshift","dispose","select","document","mode","kind","_asyncToGenerator","length","undefined","first","formatDocumentRangesWithSelectedProvider","_x","_x2","_x3","_x4","_x5","_x6","_x7","_formatDocumentRangesWithSelectedProvider","apply","arguments","accessor","editorOrModel","rangeOrRanges","progress","userGesture","instaService","get","documentRangeFormattingEditProviderRegistry","getModel","provider","selected","report","invokeFunction","formatDocumentRangesWithProvider","_x8","_x9","_x0","_x1","_x10","_x11","_formatDocumentRangesWithProvider","workerService","logService","accessibilitySignalService","cts","ranges","len","range","sort","compareRangesUsingStarts","areIntersectingOrTouching","fromPositions","getStartPosition","getEndPosition","computeEdits","_ref4","trace","value","getFormattingOptions","_x38","hasIntersectingEdit","a","b","mergedA","reduce","acc","val","plusRange","some","x","intersectRanges","edit","otherEdit","allEdits","rawEditsList","provideDocumentRangesFormattingEdits","isCancellationRequested","i","j","mergedRange","edits","splice","rawEdits","minimalEdits","computeMoreMinimalEdits","uri","execute","revealPositionInCenterIfOutsideViewport","getPosition","initialSelection","startLineNumber","startColumn","endLineNumber","endColumn","pushEditOperations","map","text","lift","forceMoveMarkers","undoEdits","playSignal","format","formatDocumentWithSelectedProvider","_x12","_x13","_x14","_x15","_x16","_x17","_formatDocumentWithSelectedProvider","languageFeaturesService","formatDocumentWithProvider","_x18","_x19","_x20","_x21","_x22","_x23","_formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","_x24","_x25","_x26","_x27","_x28","_x29","_getDocumentRangeFormattingEditsUntilResult","providers","Promise","resolve","catch","getDocumentFormattingEditsUntilResult","_x30","_x31","_x32","_x33","_x34","_getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","position","ch","onTypeFormattingEditProvider","autoFormatTriggerCharacters","indexOf","provideOnTypeFormattingEdits","then","registerCommand","_ref","args","resource","isUri","isIRange","resolverService","reference","createModelReference","object","textEditorModel","None","_x35","_ref2","_x36","_ref3","isIPosition","_x37"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/format.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nimport { AccessibilitySignal, IAccessibilitySignalService } from '../../../../platform/accessibilitySignal/browser/accessibilitySignalService.js';\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n    const result = [];\n    const seen = new ExtensionIdentifierSet();\n    // (1) add all document formatter\n    const docFormatter = documentFormattingEditProvider.ordered(model);\n    for (const formatter of docFormatter) {\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(formatter.extensionId);\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n    for (const formatter of rangeFormatter) {\n        if (formatter.extensionId) {\n            if (seen.has(formatter.extensionId)) {\n                continue;\n            }\n            seen.add(formatter.extensionId);\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits(model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    }\n    return result;\n}\nexport class FormattingConflicts {\n    static { this._selectors = new LinkedList(); }\n    static setFormatterSelector(selector) {\n        const remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    }\n    static async select(formatter, document, mode, kind) {\n        if (formatter.length === 0) {\n            return undefined;\n        }\n        const selector = Iterable.first(FormattingConflicts._selectors);\n        if (selector) {\n            return await selector(formatter, document, mode, kind);\n        }\n        return undefined;\n    }\n}\nexport async function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = await FormattingConflicts.select(provider, model, mode, 2 /* FormattingKind.Selection */);\n    if (selected) {\n        progress.report(selected);\n        await instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token, userGesture);\n    }\n}\nexport async function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const logService = accessor.get(ILogService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n        model = editorOrModel.getModel();\n        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    }\n    else {\n        model = editorOrModel;\n        cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    // make sure that ranges don't overlap nor touch each other\n    const ranges = [];\n    let len = 0;\n    for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n        if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n            ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n        }\n        else {\n            len = ranges.push(range);\n        }\n    }\n    const computeEdits = async (range) => {\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, range);\n        const result = (await provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n        return result;\n    };\n    const hasIntersectingEdit = (a, b) => {\n        if (!a.length || !b.length) {\n            return false;\n        }\n        // quick exit if the list of ranges are completely unrelated [O(n)]\n        const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);\n        if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {\n            return false;\n        }\n        // fallback to a complete check [O(n^2)]\n        for (const edit of a) {\n            for (const otherEdit of b) {\n                if (Range.intersectRanges(edit.range, otherEdit.range)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    const allEdits = [];\n    const rawEditsList = [];\n    try {\n        if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, provider.extensionId?.value, ranges);\n            const result = (await provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, provider.extensionId?.value, result);\n            rawEditsList.push(result);\n        }\n        else {\n            for (const range of ranges) {\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n                rawEditsList.push(await computeEdits(range));\n            }\n            for (let i = 0; i < ranges.length; ++i) {\n                for (let j = i + 1; j < ranges.length; ++j) {\n                    if (cts.token.isCancellationRequested) {\n                        return true;\n                    }\n                    if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n                        // Merge ranges i and j into a single range, recompute the associated edits\n                        const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n                        const edits = await computeEdits(mergedRange);\n                        ranges.splice(j, 1);\n                        ranges.splice(i, 1);\n                        ranges.push(mergedRange);\n                        rawEditsList.splice(j, 1);\n                        rawEditsList.splice(i, 1);\n                        rawEditsList.push(edits);\n                        // Restart scanning\n                        i = 0;\n                        j = 0;\n                    }\n                }\n            }\n        }\n        for (const rawEdits of rawEditsList) {\n            if (cts.token.isCancellationRequested) {\n                return true;\n            }\n            const minimalEdits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (minimalEdits) {\n                allEdits.push(...minimalEdits);\n            }\n        }\n    }\n    finally {\n        cts.dispose();\n    }\n    if (allEdits.length === 0) {\n        return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n        // use editor to apply edits\n        FormattingEdit.execute(editorOrModel, allEdits, true);\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n    }\n    else {\n        // use model to apply edits\n        const [{ range }] = allEdits;\n        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        model.pushEditOperations([initialSelection], allEdits.map(edit => {\n            return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n            };\n        }), undoEdits => {\n            for (const { range } of undoEdits) {\n                if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                }\n            }\n            return null;\n        });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n    return true;\n}\nexport async function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token, userGesture) {\n    const instaService = accessor.get(IInstantiationService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    const selected = await FormattingConflicts.select(provider, model, mode, 1 /* FormattingKind.File */);\n    if (selected) {\n        progress.report(selected);\n        await instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token, userGesture);\n    }\n}\nexport async function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token, userGesture) {\n    const workerService = accessor.get(IEditorWorkerService);\n    const accessibilitySignalService = accessor.get(IAccessibilitySignalService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n        model = editorOrModel.getModel();\n        cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    }\n    else {\n        model = editorOrModel;\n        cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    let edits;\n    try {\n        const rawEdits = await provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n        edits = await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        if (cts.token.isCancellationRequested) {\n            return true;\n        }\n    }\n    finally {\n        cts.dispose();\n    }\n    if (!edits || edits.length === 0) {\n        return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n        // use editor to apply edits\n        FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n        if (mode !== 2 /* FormattingMode.Silent */) {\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n        }\n    }\n    else {\n        // use model to apply edits\n        const [{ range }] = edits;\n        const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        model.pushEditOperations([initialSelection], edits.map(edit => {\n            return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n            };\n        }), undoEdits => {\n            for (const { range } of undoEdits) {\n                if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                    return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                }\n            }\n            return null;\n        });\n    }\n    accessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture });\n    return true;\n}\nexport async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {\n    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n    for (const provider of providers) {\n        const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n        if (isNonEmptyArray(rawEdits)) {\n            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        }\n    }\n    return undefined;\n}\nexport async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    for (const provider of providers) {\n        const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n        if (isNonEmptyArray(rawEdits)) {\n            return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        }\n    }\n    return undefined;\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n    const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', async function (accessor, ...args) {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', async function (accessor, ...args) {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', async function (accessor, ...args) {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = await resolverService.createModelReference(resource);\n    try {\n        return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n    }\n    finally {\n        reference.dispose();\n    }\n});\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,EAAEC,eAAe,QAAQ,mCAAmC;AAC5E,SAASC,iBAAiB,QAAQ,yCAAyC;AAC3E,SAASC,yBAAyB,QAAQ,mCAAmC;AAC7E,SAASC,QAAQ,QAAQ,qCAAqC;AAC9D,SAASC,UAAU,QAAQ,uCAAuC;AAClE,SAASC,UAAU,QAAQ,kCAAkC;AAC7D,SAASC,GAAG,QAAQ,gCAAgC;AACpD,SAASC,kCAAkC,EAAEC,gCAAgC,QAAQ,0CAA0C;AAC/H,SAASC,YAAY,QAAQ,mCAAmC;AAChE,SAASC,QAAQ,QAAQ,kCAAkC;AAC3D,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,SAAS,QAAQ,mCAAmC;AAC7D,SAASC,oBAAoB,QAAQ,0CAA0C;AAC/E,SAASC,iBAAiB,QAAQ,6CAA6C;AAC/E,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,gBAAgB,QAAQ,kDAAkD;AACnF,SAASC,sBAAsB,QAAQ,sDAAsD;AAC7F,SAASC,qBAAqB,QAAQ,4DAA4D;AAClG,SAASC,wBAAwB,QAAQ,8CAA8C;AACvF,SAASC,WAAW,QAAQ,wCAAwC;AACpE,SAASC,mBAAmB,EAAEC,2BAA2B,QAAQ,gFAAgF;AACjJ,OAAO,SAASC,4CAA4CA,CAACC,8BAA8B,EAAEC,mCAAmC,EAAEC,KAAK,EAAE;EACrI,MAAMC,MAAM,GAAG,EAAE;EACjB,MAAMC,IAAI,GAAG,IAAIX,sBAAsB,CAAC,CAAC;EACzC;EACA,MAAMY,YAAY,GAAGL,8BAA8B,CAACM,OAAO,CAACJ,KAAK,CAAC;EAClE,KAAK,MAAMK,SAAS,IAAIF,YAAY,EAAE;IAClCF,MAAM,CAACK,IAAI,CAACD,SAAS,CAAC;IACtB,IAAIA,SAAS,CAACE,WAAW,EAAE;MACvBL,IAAI,CAACM,GAAG,CAACH,SAAS,CAACE,WAAW,CAAC;IACnC;EACJ;EACA;EACA,MAAME,cAAc,GAAGV,mCAAmC,CAACK,OAAO,CAACJ,KAAK,CAAC;EACzE,KAAK,MAAMK,SAAS,IAAII,cAAc,EAAE;IACpC,IAAIJ,SAAS,CAACE,WAAW,EAAE;MACvB,IAAIL,IAAI,CAACQ,GAAG,CAACL,SAAS,CAACE,WAAW,CAAC,EAAE;QACjC;MACJ;MACAL,IAAI,CAACM,GAAG,CAACH,SAAS,CAACE,WAAW,CAAC;IACnC;IACAN,MAAM,CAACK,IAAI,CAAC;MACRK,WAAW,EAAEN,SAAS,CAACM,WAAW;MAClCJ,WAAW,EAAEF,SAAS,CAACE,WAAW;MAClCK,8BAA8BA,CAACZ,KAAK,EAAEa,OAAO,EAAEC,KAAK,EAAE;QAClD,OAAOT,SAAS,CAACU,mCAAmC,CAACf,KAAK,EAAEA,KAAK,CAACgB,iBAAiB,CAAC,CAAC,EAAEH,OAAO,EAAEC,KAAK,CAAC;MAC1G;IACJ,CAAC,CAAC;EACN;EACA,OAAOb,MAAM;AACjB;AACA,OAAO,MAAMgB,mBAAmB,CAAC;EAAA,QAAAC,CAAA,GACpB,IAAI,CAACC,UAAU,GAAG,IAAIzC,UAAU,CAAC,CAAC;EAC3C,OAAO0C,oBAAoBA,CAACC,QAAQ,EAAE;IAClC,MAAMC,MAAM,GAAGL,mBAAmB,CAACE,UAAU,CAACI,OAAO,CAACF,QAAQ,CAAC;IAC/D,OAAO;MAAEG,OAAO,EAAEF;IAAO,CAAC;EAC9B;EACA,OAAaG,MAAMA,CAACpB,SAAS,EAAEqB,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAAA,OAAAC,iBAAA;MACjD,IAAIxB,SAAS,CAACyB,MAAM,KAAK,CAAC,EAAE;QACxB,OAAOC,SAAS;MACpB;MACA,MAAMV,QAAQ,GAAG5C,QAAQ,CAACuD,KAAK,CAACf,mBAAmB,CAACE,UAAU,CAAC;MAC/D,IAAIE,QAAQ,EAAE;QACV,aAAaA,QAAQ,CAAChB,SAAS,EAAEqB,QAAQ,EAAEC,IAAI,EAAEC,IAAI,CAAC;MAC1D;MACA,OAAOG,SAAS;IAAC;EACrB;AACJ;AACA,gBAAsBE,wCAAwCA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,yCAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAU7D,SAAAF,0CAAA;EAAAA,yCAAA,GAAAZ,iBAAA,CAVM,WAAwDe,QAAQ,EAAEC,aAAa,EAAEC,aAAa,EAAEnB,IAAI,EAAEoB,QAAQ,EAAEjC,KAAK,EAAEkC,WAAW,EAAE;IACvI,MAAMC,YAAY,GAAGL,QAAQ,CAACM,GAAG,CAAC1D,qBAAqB,CAAC;IACxD,MAAM;MAAEO,mCAAmC,EAAEoD;IAA4C,CAAC,GAAGP,QAAQ,CAACM,GAAG,CAACzD,wBAAwB,CAAC;IACnI,MAAMO,KAAK,GAAGjB,YAAY,CAAC8D,aAAa,CAAC,GAAGA,aAAa,CAACO,QAAQ,CAAC,CAAC,GAAGP,aAAa;IACpF,MAAMQ,QAAQ,GAAGF,2CAA2C,CAAC/C,OAAO,CAACJ,KAAK,CAAC;IAC3E,MAAMsD,QAAQ,SAASrC,mBAAmB,CAACQ,MAAM,CAAC4B,QAAQ,EAAErD,KAAK,EAAE2B,IAAI,EAAE,CAAC,CAAC,8BAA8B,CAAC;IAC1G,IAAI2B,QAAQ,EAAE;MACVP,QAAQ,CAACQ,MAAM,CAACD,QAAQ,CAAC;MACzB,MAAML,YAAY,CAACO,cAAc,CAACC,gCAAgC,EAAEH,QAAQ,EAAET,aAAa,EAAEC,aAAa,EAAEhC,KAAK,EAAEkC,WAAW,CAAC;IACnI;EACJ,CAAC;EAAA,OAAAP,yCAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsBc,gCAAgCA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,iCAAA,CAAAtB,KAAA,OAAAC,SAAA;AAAA;AAkIrD,SAAAqB,kCAAA;EAAAA,iCAAA,GAAAnC,iBAAA,CAlIM,WAAgDe,QAAQ,EAAES,QAAQ,EAAER,aAAa,EAAEC,aAAa,EAAEhC,KAAK,EAAEkC,WAAW,EAAE;IACzH,MAAMiB,aAAa,GAAGrB,QAAQ,CAACM,GAAG,CAAC/D,oBAAoB,CAAC;IACxD,MAAM+E,UAAU,GAAGtB,QAAQ,CAACM,GAAG,CAACxD,WAAW,CAAC;IAC5C,MAAMyE,0BAA0B,GAAGvB,QAAQ,CAACM,GAAG,CAACtD,2BAA2B,CAAC;IAC5E,IAAII,KAAK;IACT,IAAIoE,GAAG;IACP,IAAIrF,YAAY,CAAC8D,aAAa,CAAC,EAAE;MAC7B7C,KAAK,GAAG6C,aAAa,CAACO,QAAQ,CAAC,CAAC;MAChCgB,GAAG,GAAG,IAAIvF,kCAAkC,CAACgE,aAAa,EAAE,CAAC,CAAC,kCAAkC,CAAC,CAAC,oCAAoCd,SAAS,EAAEjB,KAAK,CAAC;IAC3J,CAAC,MACI;MACDd,KAAK,GAAG6C,aAAa;MACrBuB,GAAG,GAAG,IAAItF,gCAAgC,CAAC+D,aAAa,EAAE/B,KAAK,CAAC;IACpE;IACA;IACA,MAAMuD,MAAM,GAAG,EAAE;IACjB,IAAIC,GAAG,GAAG,CAAC;IACX,KAAK,MAAMC,KAAK,IAAIlG,OAAO,CAACyE,aAAa,CAAC,CAAC0B,IAAI,CAACvF,KAAK,CAACwF,wBAAwB,CAAC,EAAE;MAC7E,IAAIH,GAAG,GAAG,CAAC,IAAIrF,KAAK,CAACyF,yBAAyB,CAACL,MAAM,CAACC,GAAG,GAAG,CAAC,CAAC,EAAEC,KAAK,CAAC,EAAE;QACpEF,MAAM,CAACC,GAAG,GAAG,CAAC,CAAC,GAAGrF,KAAK,CAAC0F,aAAa,CAACN,MAAM,CAACC,GAAG,GAAG,CAAC,CAAC,CAACM,gBAAgB,CAAC,CAAC,EAAEL,KAAK,CAACM,cAAc,CAAC,CAAC,CAAC;MACrG,CAAC,MACI;QACDP,GAAG,GAAGD,MAAM,CAAC/D,IAAI,CAACiE,KAAK,CAAC;MAC5B;IACJ;IACA,MAAMO,YAAY;MAAA,IAAAC,KAAA,GAAAlD,iBAAA,CAAG,WAAO0C,KAAK,EAAK;QAClCL,UAAU,CAACc,KAAK,CAAC,yDAAyD,EAAE3B,QAAQ,CAAC9C,WAAW,EAAE0E,KAAK,EAAEV,KAAK,CAAC;QAC/G,MAAMtE,MAAM,GAAG,OAAOoD,QAAQ,CAACtC,mCAAmC,CAACf,KAAK,EAAEuE,KAAK,EAAEvE,KAAK,CAACkF,oBAAoB,CAAC,CAAC,EAAEd,GAAG,CAACtD,KAAK,CAAC,KAAK,EAAE;QAChIoD,UAAU,CAACc,KAAK,CAAC,0DAA0D,EAAE3B,QAAQ,CAAC9C,WAAW,EAAE0E,KAAK,EAAEhF,MAAM,CAAC;QACjH,OAAOA,MAAM;MACjB,CAAC;MAAA,gBALK6E,YAAYA,CAAAK,IAAA;QAAA,OAAAJ,KAAA,CAAArC,KAAA,OAAAC,SAAA;MAAA;IAAA,GAKjB;IACD,MAAMyC,mBAAmB,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;MAClC,IAAI,CAACD,CAAC,CAACvD,MAAM,IAAI,CAACwD,CAAC,CAACxD,MAAM,EAAE;QACxB,OAAO,KAAK;MAChB;MACA;MACA,MAAMyD,OAAO,GAAGF,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;QAAE,OAAOzG,KAAK,CAAC0G,SAAS,CAACF,GAAG,EAAEC,GAAG,CAACnB,KAAK,CAAC;MAAE,CAAC,EAAEc,CAAC,CAAC,CAAC,CAAC,CAACd,KAAK,CAAC;MAC/F,IAAI,CAACe,CAAC,CAACM,IAAI,CAACC,CAAC,IAAI;QAAE,OAAO5G,KAAK,CAAC6G,eAAe,CAACP,OAAO,EAAEM,CAAC,CAACtB,KAAK,CAAC;MAAE,CAAC,CAAC,EAAE;QACnE,OAAO,KAAK;MAChB;MACA;MACA,KAAK,MAAMwB,IAAI,IAAIV,CAAC,EAAE;QAClB,KAAK,MAAMW,SAAS,IAAIV,CAAC,EAAE;UACvB,IAAIrG,KAAK,CAAC6G,eAAe,CAACC,IAAI,CAACxB,KAAK,EAAEyB,SAAS,CAACzB,KAAK,CAAC,EAAE;YACpD,OAAO,IAAI;UACf;QACJ;MACJ;MACA,OAAO,KAAK;IAChB,CAAC;IACD,MAAM0B,QAAQ,GAAG,EAAE;IACnB,MAAMC,YAAY,GAAG,EAAE;IACvB,IAAI;MACA,IAAI,OAAO7C,QAAQ,CAAC8C,oCAAoC,KAAK,UAAU,EAAE;QACrEjC,UAAU,CAACc,KAAK,CAAC,yDAAyD,EAAE3B,QAAQ,CAAC9C,WAAW,EAAE0E,KAAK,EAAEZ,MAAM,CAAC;QAChH,MAAMpE,MAAM,GAAG,OAAOoD,QAAQ,CAAC8C,oCAAoC,CAACnG,KAAK,EAAEqE,MAAM,EAAErE,KAAK,CAACkF,oBAAoB,CAAC,CAAC,EAAEd,GAAG,CAACtD,KAAK,CAAC,KAAK,EAAE;QAClIoD,UAAU,CAACc,KAAK,CAAC,0DAA0D,EAAE3B,QAAQ,CAAC9C,WAAW,EAAE0E,KAAK,EAAEhF,MAAM,CAAC;QACjHiG,YAAY,CAAC5F,IAAI,CAACL,MAAM,CAAC;MAC7B,CAAC,MACI;QACD,KAAK,MAAMsE,KAAK,IAAIF,MAAM,EAAE;UACxB,IAAID,GAAG,CAACtD,KAAK,CAACsF,uBAAuB,EAAE;YACnC,OAAO,IAAI;UACf;UACAF,YAAY,CAAC5F,IAAI,OAAOwE,YAAY,CAACP,KAAK,CAAC,CAAC;QAChD;QACA,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhC,MAAM,CAACvC,MAAM,EAAE,EAAEuE,CAAC,EAAE;UACpC,KAAK,IAAIC,CAAC,GAAGD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGjC,MAAM,CAACvC,MAAM,EAAE,EAAEwE,CAAC,EAAE;YACxC,IAAIlC,GAAG,CAACtD,KAAK,CAACsF,uBAAuB,EAAE;cACnC,OAAO,IAAI;YACf;YACA,IAAIhB,mBAAmB,CAACc,YAAY,CAACG,CAAC,CAAC,EAAEH,YAAY,CAACI,CAAC,CAAC,CAAC,EAAE;cACvD;cACA,MAAMC,WAAW,GAAGtH,KAAK,CAAC0G,SAAS,CAACtB,MAAM,CAACgC,CAAC,CAAC,EAAEhC,MAAM,CAACiC,CAAC,CAAC,CAAC;cACzD,MAAME,KAAK,SAAS1B,YAAY,CAACyB,WAAW,CAAC;cAC7ClC,MAAM,CAACoC,MAAM,CAACH,CAAC,EAAE,CAAC,CAAC;cACnBjC,MAAM,CAACoC,MAAM,CAACJ,CAAC,EAAE,CAAC,CAAC;cACnBhC,MAAM,CAAC/D,IAAI,CAACiG,WAAW,CAAC;cACxBL,YAAY,CAACO,MAAM,CAACH,CAAC,EAAE,CAAC,CAAC;cACzBJ,YAAY,CAACO,MAAM,CAACJ,CAAC,EAAE,CAAC,CAAC;cACzBH,YAAY,CAAC5F,IAAI,CAACkG,KAAK,CAAC;cACxB;cACAH,CAAC,GAAG,CAAC;cACLC,CAAC,GAAG,CAAC;YACT;UACJ;QACJ;MACJ;MACA,KAAK,MAAMI,QAAQ,IAAIR,YAAY,EAAE;QACjC,IAAI9B,GAAG,CAACtD,KAAK,CAACsF,uBAAuB,EAAE;UACnC,OAAO,IAAI;QACf;QACA,MAAMO,YAAY,SAAS1C,aAAa,CAAC2C,uBAAuB,CAAC5G,KAAK,CAAC6G,GAAG,EAAEH,QAAQ,CAAC;QACrF,IAAIC,YAAY,EAAE;UACdV,QAAQ,CAAC3F,IAAI,CAAC,GAAGqG,YAAY,CAAC;QAClC;MACJ;IACJ,CAAC,SACO;MACJvC,GAAG,CAAC5C,OAAO,CAAC,CAAC;IACjB;IACA,IAAIyE,QAAQ,CAACnE,MAAM,KAAK,CAAC,EAAE;MACvB,OAAO,KAAK;IAChB;IACA,IAAI/C,YAAY,CAAC8D,aAAa,CAAC,EAAE;MAC7B;MACAxD,cAAc,CAACyH,OAAO,CAACjE,aAAa,EAAEoD,QAAQ,EAAE,IAAI,CAAC;MACrDpD,aAAa,CAACkE,uCAAuC,CAAClE,aAAa,CAACmE,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,0BAA0B,CAAC;IACpH,CAAC,MACI;MACD;MACA,MAAM,CAAC;QAAEzC;MAAM,CAAC,CAAC,GAAG0B,QAAQ;MAC5B,MAAMgB,gBAAgB,GAAG,IAAI/H,SAAS,CAACqF,KAAK,CAAC2C,eAAe,EAAE3C,KAAK,CAAC4C,WAAW,EAAE5C,KAAK,CAAC6C,aAAa,EAAE7C,KAAK,CAAC8C,SAAS,CAAC;MACtHrH,KAAK,CAACsH,kBAAkB,CAAC,CAACL,gBAAgB,CAAC,EAAEhB,QAAQ,CAACsB,GAAG,CAACxB,IAAI,IAAI;QAC9D,OAAO;UACHyB,IAAI,EAAEzB,IAAI,CAACyB,IAAI;UACfjD,KAAK,EAAEtF,KAAK,CAACwI,IAAI,CAAC1B,IAAI,CAACxB,KAAK,CAAC;UAC7BmD,gBAAgB,EAAE;QACtB,CAAC;MACL,CAAC,CAAC,EAAEC,SAAS,IAAI;QACb,KAAK,MAAM;UAAEpD;QAAM,CAAC,IAAIoD,SAAS,EAAE;UAC/B,IAAI1I,KAAK,CAACyF,yBAAyB,CAACH,KAAK,EAAE0C,gBAAgB,CAAC,EAAE;YAC1D,OAAO,CAAC,IAAI/H,SAAS,CAACqF,KAAK,CAAC2C,eAAe,EAAE3C,KAAK,CAAC4C,WAAW,EAAE5C,KAAK,CAAC6C,aAAa,EAAE7C,KAAK,CAAC8C,SAAS,CAAC,CAAC;UAC1G;QACJ;QACA,OAAO,IAAI;MACf,CAAC,CAAC;IACN;IACAlD,0BAA0B,CAACyD,UAAU,CAACjI,mBAAmB,CAACkI,MAAM,EAAE;MAAE7E;IAAY,CAAC,CAAC;IAClF,OAAO,IAAI;EACf,CAAC;EAAA,OAAAgB,iCAAA,CAAAtB,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsBmF,kCAAkCA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,mCAAA,CAAA3F,KAAA,OAAAC,SAAA;AAAA;AAUvD,SAAA0F,oCAAA;EAAAA,mCAAA,GAAAxG,iBAAA,CAVM,WAAkDe,QAAQ,EAAEC,aAAa,EAAElB,IAAI,EAAEoB,QAAQ,EAAEjC,KAAK,EAAEkC,WAAW,EAAE;IAClH,MAAMC,YAAY,GAAGL,QAAQ,CAACM,GAAG,CAAC1D,qBAAqB,CAAC;IACxD,MAAM8I,uBAAuB,GAAG1F,QAAQ,CAACM,GAAG,CAACzD,wBAAwB,CAAC;IACtE,MAAMO,KAAK,GAAGjB,YAAY,CAAC8D,aAAa,CAAC,GAAGA,aAAa,CAACO,QAAQ,CAAC,CAAC,GAAGP,aAAa;IACpF,MAAMQ,QAAQ,GAAGxD,4CAA4C,CAACyI,uBAAuB,CAACxI,8BAA8B,EAAEwI,uBAAuB,CAACvI,mCAAmC,EAAEC,KAAK,CAAC;IACzL,MAAMsD,QAAQ,SAASrC,mBAAmB,CAACQ,MAAM,CAAC4B,QAAQ,EAAErD,KAAK,EAAE2B,IAAI,EAAE,CAAC,CAAC,yBAAyB,CAAC;IACrG,IAAI2B,QAAQ,EAAE;MACVP,QAAQ,CAACQ,MAAM,CAACD,QAAQ,CAAC;MACzB,MAAML,YAAY,CAACO,cAAc,CAAC+E,0BAA0B,EAAEjF,QAAQ,EAAET,aAAa,EAAElB,IAAI,EAAEb,KAAK,EAAEkC,WAAW,CAAC;IACpH;EACJ,CAAC;EAAA,OAAAqF,mCAAA,CAAA3F,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsB4F,0BAA0BA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,2BAAA,CAAApG,KAAA,OAAAC,SAAA;AAAA;AAuD/C,SAAAmG,4BAAA;EAAAA,2BAAA,GAAAjH,iBAAA,CAvDM,WAA0Ce,QAAQ,EAAES,QAAQ,EAAER,aAAa,EAAElB,IAAI,EAAEb,KAAK,EAAEkC,WAAW,EAAE;IAC1G,MAAMiB,aAAa,GAAGrB,QAAQ,CAACM,GAAG,CAAC/D,oBAAoB,CAAC;IACxD,MAAMgF,0BAA0B,GAAGvB,QAAQ,CAACM,GAAG,CAACtD,2BAA2B,CAAC;IAC5E,IAAII,KAAK;IACT,IAAIoE,GAAG;IACP,IAAIrF,YAAY,CAAC8D,aAAa,CAAC,EAAE;MAC7B7C,KAAK,GAAG6C,aAAa,CAACO,QAAQ,CAAC,CAAC;MAChCgB,GAAG,GAAG,IAAIvF,kCAAkC,CAACgE,aAAa,EAAE,CAAC,CAAC,kCAAkC,CAAC,CAAC,oCAAoCd,SAAS,EAAEjB,KAAK,CAAC;IAC3J,CAAC,MACI;MACDd,KAAK,GAAG6C,aAAa;MACrBuB,GAAG,GAAG,IAAItF,gCAAgC,CAAC+D,aAAa,EAAE/B,KAAK,CAAC;IACpE;IACA,IAAI0F,KAAK;IACT,IAAI;MACA,MAAME,QAAQ,SAASrD,QAAQ,CAACzC,8BAA8B,CAACZ,KAAK,EAAEA,KAAK,CAACkF,oBAAoB,CAAC,CAAC,EAAEd,GAAG,CAACtD,KAAK,CAAC;MAC9G0F,KAAK,SAASvC,aAAa,CAAC2C,uBAAuB,CAAC5G,KAAK,CAAC6G,GAAG,EAAEH,QAAQ,CAAC;MACxE,IAAItC,GAAG,CAACtD,KAAK,CAACsF,uBAAuB,EAAE;QACnC,OAAO,IAAI;MACf;IACJ,CAAC,SACO;MACJhC,GAAG,CAAC5C,OAAO,CAAC,CAAC;IACjB;IACA,IAAI,CAACgF,KAAK,IAAIA,KAAK,CAAC1E,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAO,KAAK;IAChB;IACA,IAAI/C,YAAY,CAAC8D,aAAa,CAAC,EAAE;MAC7B;MACAxD,cAAc,CAACyH,OAAO,CAACjE,aAAa,EAAE2D,KAAK,EAAE7E,IAAI,KAAK,CAAC,CAAC,2BAA2B,CAAC;MACpF,IAAIA,IAAI,KAAK,CAAC,CAAC,6BAA6B;QACxCkB,aAAa,CAACkE,uCAAuC,CAAClE,aAAa,CAACmE,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,0BAA0B,CAAC;MACpH;IACJ,CAAC,MACI;MACD;MACA,MAAM,CAAC;QAAEzC;MAAM,CAAC,CAAC,GAAGiC,KAAK;MACzB,MAAMS,gBAAgB,GAAG,IAAI/H,SAAS,CAACqF,KAAK,CAAC2C,eAAe,EAAE3C,KAAK,CAAC4C,WAAW,EAAE5C,KAAK,CAAC6C,aAAa,EAAE7C,KAAK,CAAC8C,SAAS,CAAC;MACtHrH,KAAK,CAACsH,kBAAkB,CAAC,CAACL,gBAAgB,CAAC,EAAET,KAAK,CAACe,GAAG,CAACxB,IAAI,IAAI;QAC3D,OAAO;UACHyB,IAAI,EAAEzB,IAAI,CAACyB,IAAI;UACfjD,KAAK,EAAEtF,KAAK,CAACwI,IAAI,CAAC1B,IAAI,CAACxB,KAAK,CAAC;UAC7BmD,gBAAgB,EAAE;QACtB,CAAC;MACL,CAAC,CAAC,EAAEC,SAAS,IAAI;QACb,KAAK,MAAM;UAAEpD;QAAM,CAAC,IAAIoD,SAAS,EAAE;UAC/B,IAAI1I,KAAK,CAACyF,yBAAyB,CAACH,KAAK,EAAE0C,gBAAgB,CAAC,EAAE;YAC1D,OAAO,CAAC,IAAI/H,SAAS,CAACqF,KAAK,CAAC2C,eAAe,EAAE3C,KAAK,CAAC4C,WAAW,EAAE5C,KAAK,CAAC6C,aAAa,EAAE7C,KAAK,CAAC8C,SAAS,CAAC,CAAC;UAC1G;QACJ;QACA,OAAO,IAAI;MACf,CAAC,CAAC;IACN;IACAlD,0BAA0B,CAACyD,UAAU,CAACjI,mBAAmB,CAACkI,MAAM,EAAE;MAAE7E;IAAY,CAAC,CAAC;IAClF,OAAO,IAAI;EACf,CAAC;EAAA,OAAA8F,2BAAA,CAAApG,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsBoG,0CAA0CA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,2CAAA,CAAA5G,KAAA,OAAAC,SAAA;AAAA;AAS/D,SAAA2G,4CAAA;EAAAA,2CAAA,GAAAzH,iBAAA,CATM,WAA0DoC,aAAa,EAAEqE,uBAAuB,EAAEtI,KAAK,EAAEuE,KAAK,EAAE1D,OAAO,EAAEC,KAAK,EAAE;IACnI,MAAMyI,SAAS,GAAGjB,uBAAuB,CAACvI,mCAAmC,CAACK,OAAO,CAACJ,KAAK,CAAC;IAC5F,KAAK,MAAMqD,QAAQ,IAAIkG,SAAS,EAAE;MAC9B,MAAM7C,QAAQ,SAAS8C,OAAO,CAACC,OAAO,CAACpG,QAAQ,CAACtC,mCAAmC,CAACf,KAAK,EAAEuE,KAAK,EAAE1D,OAAO,EAAEC,KAAK,CAAC,CAAC,CAAC4I,KAAK,CAAClL,yBAAyB,CAAC;MACnJ,IAAIF,eAAe,CAACoI,QAAQ,CAAC,EAAE;QAC3B,aAAazC,aAAa,CAAC2C,uBAAuB,CAAC5G,KAAK,CAAC6G,GAAG,EAAEH,QAAQ,CAAC;MAC3E;IACJ;IACA,OAAO3E,SAAS;EACpB,CAAC;EAAA,OAAAuH,2CAAA,CAAA5G,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsBgH,qCAAqCA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,sCAAA,CAAAvH,KAAA,OAAAC,SAAA;AAAA;AAS1D,SAAAsH,uCAAA;EAAAA,sCAAA,GAAApI,iBAAA,CATM,WAAqDoC,aAAa,EAAEqE,uBAAuB,EAAEtI,KAAK,EAAEa,OAAO,EAAEC,KAAK,EAAE;IACvH,MAAMyI,SAAS,GAAG1J,4CAA4C,CAACyI,uBAAuB,CAACxI,8BAA8B,EAAEwI,uBAAuB,CAACvI,mCAAmC,EAAEC,KAAK,CAAC;IAC1L,KAAK,MAAMqD,QAAQ,IAAIkG,SAAS,EAAE;MAC9B,MAAM7C,QAAQ,SAAS8C,OAAO,CAACC,OAAO,CAACpG,QAAQ,CAACzC,8BAA8B,CAACZ,KAAK,EAAEa,OAAO,EAAEC,KAAK,CAAC,CAAC,CAAC4I,KAAK,CAAClL,yBAAyB,CAAC;MACvI,IAAIF,eAAe,CAACoI,QAAQ,CAAC,EAAE;QAC3B,aAAazC,aAAa,CAAC2C,uBAAuB,CAAC5G,KAAK,CAAC6G,GAAG,EAAEH,QAAQ,CAAC;MAC3E;IACJ;IACA,OAAO3E,SAAS;EACpB,CAAC;EAAA,OAAAkI,sCAAA,CAAAvH,KAAA,OAAAC,SAAA;AAAA;AACD,OAAO,SAASuH,wBAAwBA,CAACjG,aAAa,EAAEqE,uBAAuB,EAAEtI,KAAK,EAAEmK,QAAQ,EAAEC,EAAE,EAAEvJ,OAAO,EAAEC,KAAK,EAAE;EAClH,MAAMyI,SAAS,GAAGjB,uBAAuB,CAAC+B,4BAA4B,CAACjK,OAAO,CAACJ,KAAK,CAAC;EACrF,IAAIuJ,SAAS,CAACzH,MAAM,KAAK,CAAC,EAAE;IACxB,OAAO0H,OAAO,CAACC,OAAO,CAAC1H,SAAS,CAAC;EACrC;EACA,IAAIwH,SAAS,CAAC,CAAC,CAAC,CAACe,2BAA2B,CAACC,OAAO,CAACH,EAAE,CAAC,GAAG,CAAC,EAAE;IAC1D,OAAOZ,OAAO,CAACC,OAAO,CAAC1H,SAAS,CAAC;EACrC;EACA,OAAOyH,OAAO,CAACC,OAAO,CAACF,SAAS,CAAC,CAAC,CAAC,CAACiB,4BAA4B,CAACxK,KAAK,EAAEmK,QAAQ,EAAEC,EAAE,EAAEvJ,OAAO,EAAEC,KAAK,CAAC,CAAC,CAAC4I,KAAK,CAAClL,yBAAyB,CAAC,CAACiM,IAAI,CAACjE,KAAK,IAAI;IAClJ,OAAOvC,aAAa,CAAC2C,uBAAuB,CAAC5G,KAAK,CAAC6G,GAAG,EAAEL,KAAK,CAAC;EAClE,CAAC,CAAC;AACN;AACAlH,gBAAgB,CAACoL,eAAe,CAAC,6BAA6B;EAAA,IAAAC,IAAA,GAAA9I,iBAAA,CAAE,WAAgBe,QAAQ,EAAE,GAAGgI,IAAI,EAAE;IAC/F,MAAM,CAACC,QAAQ,EAAEtG,KAAK,EAAE1D,OAAO,CAAC,GAAG+J,IAAI;IACvCjM,UAAU,CAACC,GAAG,CAACkM,KAAK,CAACD,QAAQ,CAAC,CAAC;IAC/BlM,UAAU,CAACM,KAAK,CAAC8L,QAAQ,CAACxG,KAAK,CAAC,CAAC;IACjC,MAAMyG,eAAe,GAAGpI,QAAQ,CAACM,GAAG,CAAC9D,iBAAiB,CAAC;IACvD,MAAM6E,aAAa,GAAGrB,QAAQ,CAACM,GAAG,CAAC/D,oBAAoB,CAAC;IACxD,MAAMmJ,uBAAuB,GAAG1F,QAAQ,CAACM,GAAG,CAACzD,wBAAwB,CAAC;IACtE,MAAMwL,SAAS,SAASD,eAAe,CAACE,oBAAoB,CAACL,QAAQ,CAAC;IACtE,IAAI;MACA,OAAO9B,0CAA0C,CAAC9E,aAAa,EAAEqE,uBAAuB,EAAE2C,SAAS,CAACE,MAAM,CAACC,eAAe,EAAEnM,KAAK,CAACwI,IAAI,CAAClD,KAAK,CAAC,EAAE1D,OAAO,EAAEtC,iBAAiB,CAAC8M,IAAI,CAAC;IACnL,CAAC,SACO;MACJJ,SAAS,CAACzJ,OAAO,CAAC,CAAC;IACvB;EACJ,CAAC;EAAA,iBAAA8J,IAAA;IAAA,OAAAX,IAAA,CAAAjI,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC;AACFrD,gBAAgB,CAACoL,eAAe,CAAC,gCAAgC;EAAA,IAAAa,KAAA,GAAA1J,iBAAA,CAAE,WAAgBe,QAAQ,EAAE,GAAGgI,IAAI,EAAE;IAClG,MAAM,CAACC,QAAQ,EAAEhK,OAAO,CAAC,GAAG+J,IAAI;IAChCjM,UAAU,CAACC,GAAG,CAACkM,KAAK,CAACD,QAAQ,CAAC,CAAC;IAC/B,MAAMG,eAAe,GAAGpI,QAAQ,CAACM,GAAG,CAAC9D,iBAAiB,CAAC;IACvD,MAAM6E,aAAa,GAAGrB,QAAQ,CAACM,GAAG,CAAC/D,oBAAoB,CAAC;IACxD,MAAMmJ,uBAAuB,GAAG1F,QAAQ,CAACM,GAAG,CAACzD,wBAAwB,CAAC;IACtE,MAAMwL,SAAS,SAASD,eAAe,CAACE,oBAAoB,CAACL,QAAQ,CAAC;IACtE,IAAI;MACA,OAAOlB,qCAAqC,CAAC1F,aAAa,EAAEqE,uBAAuB,EAAE2C,SAAS,CAACE,MAAM,CAACC,eAAe,EAAEvK,OAAO,EAAEtC,iBAAiB,CAAC8M,IAAI,CAAC;IAC3J,CAAC,SACO;MACJJ,SAAS,CAACzJ,OAAO,CAAC,CAAC;IACvB;EACJ,CAAC;EAAA,iBAAAgK,IAAA;IAAA,OAAAD,KAAA,CAAA7I,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC;AACFrD,gBAAgB,CAACoL,eAAe,CAAC,8BAA8B;EAAA,IAAAe,KAAA,GAAA5J,iBAAA,CAAE,WAAgBe,QAAQ,EAAE,GAAGgI,IAAI,EAAE;IAChG,MAAM,CAACC,QAAQ,EAAEV,QAAQ,EAAEC,EAAE,EAAEvJ,OAAO,CAAC,GAAG+J,IAAI;IAC9CjM,UAAU,CAACC,GAAG,CAACkM,KAAK,CAACD,QAAQ,CAAC,CAAC;IAC/BlM,UAAU,CAACK,QAAQ,CAAC0M,WAAW,CAACvB,QAAQ,CAAC,CAAC;IAC1CxL,UAAU,CAAC,OAAOyL,EAAE,KAAK,QAAQ,CAAC;IAClC,MAAMY,eAAe,GAAGpI,QAAQ,CAACM,GAAG,CAAC9D,iBAAiB,CAAC;IACvD,MAAM6E,aAAa,GAAGrB,QAAQ,CAACM,GAAG,CAAC/D,oBAAoB,CAAC;IACxD,MAAMmJ,uBAAuB,GAAG1F,QAAQ,CAACM,GAAG,CAACzD,wBAAwB,CAAC;IACtE,MAAMwL,SAAS,SAASD,eAAe,CAACE,oBAAoB,CAACL,QAAQ,CAAC;IACtE,IAAI;MACA,OAAOX,wBAAwB,CAACjG,aAAa,EAAEqE,uBAAuB,EAAE2C,SAAS,CAACE,MAAM,CAACC,eAAe,EAAEpM,QAAQ,CAACyI,IAAI,CAAC0C,QAAQ,CAAC,EAAEC,EAAE,EAAEvJ,OAAO,EAAEtC,iBAAiB,CAAC8M,IAAI,CAAC;IAC3K,CAAC,SACO;MACJJ,SAAS,CAACzJ,OAAO,CAAC,CAAC;IACvB;EACJ,CAAC;EAAA,iBAAAmK,IAAA;IAAA,OAAAF,KAAA,CAAA/I,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}