{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar ModelSemanticColoring_1;\nimport { Disposable, dispose } from '../../../../base/common/lifecycle.js';\nimport * as errors from '../../../../base/common/errors.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { toMultilineTokens2 } from '../../../common/services/semanticTokensProviderStyling.js';\nimport { getDocumentSemanticTokens, hasDocumentSemanticTokensProvider, isSemanticTokens, isSemanticTokensEdits } from '../common/getSemanticTokens.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ISemanticTokensStylingService } from '../../../common/services/semanticTokensStyling.js';\nimport { registerEditorFeature } from '../../../common/editorFeatures.js';\nimport { SEMANTIC_HIGHLIGHTING_SETTING_ID, isSemanticColoringEnabled } from '../common/semanticTokensConfig.js';\nlet DocumentSemanticTokensFeature = class DocumentSemanticTokensFeature extends Disposable {\n  constructor(semanticTokensStylingService, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {\n    super();\n    this._watchers = Object.create(null);\n    const register = model => {\n      this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService);\n    };\n    const deregister = (model, modelSemanticColoring) => {\n      modelSemanticColoring.dispose();\n      delete this._watchers[model.uri.toString()];\n    };\n    const handleSettingOrThemeChange = () => {\n      for (const model of modelService.getModels()) {\n        const curr = this._watchers[model.uri.toString()];\n        if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n          if (!curr) {\n            register(model);\n          }\n        } else {\n          if (curr) {\n            deregister(model, curr);\n          }\n        }\n      }\n    };\n    modelService.getModels().forEach(model => {\n      if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n        register(model);\n      }\n    });\n    this._register(modelService.onModelAdded(model => {\n      if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n        register(model);\n      }\n    }));\n    this._register(modelService.onModelRemoved(model => {\n      const curr = this._watchers[model.uri.toString()];\n      if (curr) {\n        deregister(model, curr);\n      }\n    }));\n    this._register(configurationService.onDidChangeConfiguration(e => {\n      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {\n        handleSettingOrThemeChange();\n      }\n    }));\n    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));\n  }\n  dispose() {\n    // Dispose all watchers\n    for (const watcher of Object.values(this._watchers)) {\n      watcher.dispose();\n    }\n    super.dispose();\n  }\n};\nDocumentSemanticTokensFeature = __decorate([__param(0, ISemanticTokensStylingService), __param(1, IModelService), __param(2, IThemeService), __param(3, IConfigurationService), __param(4, ILanguageFeatureDebounceService), __param(5, ILanguageFeaturesService)], DocumentSemanticTokensFeature);\nexport { DocumentSemanticTokensFeature };\nlet ModelSemanticColoring = /*#__PURE__*/(() => {\n  let ModelSemanticColoring = class ModelSemanticColoring extends Disposable {\n    static #_ = ModelSemanticColoring_1 = this;\n    static #_2 = this.REQUEST_MIN_DELAY = 300;\n    static #_3 = this.REQUEST_MAX_DELAY = 2000;\n    constructor(model, _semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService) {\n      super();\n      this._semanticTokensStylingService = _semanticTokensStylingService;\n      this._isDisposed = false;\n      this._model = model;\n      this._provider = languageFeaturesService.documentSemanticTokensProvider;\n      this._debounceInformation = languageFeatureDebounceService.for(this._provider, 'DocumentSemanticTokens', {\n        min: ModelSemanticColoring_1.REQUEST_MIN_DELAY,\n        max: ModelSemanticColoring_1.REQUEST_MAX_DELAY\n      });\n      this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring_1.REQUEST_MIN_DELAY));\n      this._currentDocumentResponse = null;\n      this._currentDocumentRequestCancellationTokenSource = null;\n      this._documentProvidersChangeListeners = [];\n      this._providersChangedDuringRequest = false;\n      this._register(this._model.onDidChangeContent(() => {\n        if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }\n      }));\n      this._register(this._model.onDidChangeAttached(() => {\n        if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }\n      }));\n      this._register(this._model.onDidChangeLanguage(() => {\n        // clear any outstanding state\n        if (this._currentDocumentResponse) {\n          this._currentDocumentResponse.dispose();\n          this._currentDocumentResponse = null;\n        }\n        if (this._currentDocumentRequestCancellationTokenSource) {\n          this._currentDocumentRequestCancellationTokenSource.cancel();\n          this._currentDocumentRequestCancellationTokenSource = null;\n        }\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._fetchDocumentSemanticTokens.schedule(0);\n      }));\n      const bindDocumentChangeListeners = () => {\n        dispose(this._documentProvidersChangeListeners);\n        this._documentProvidersChangeListeners = [];\n        for (const provider of this._provider.all(model)) {\n          if (typeof provider.onDidChange === 'function') {\n            this._documentProvidersChangeListeners.push(provider.onDidChange(() => {\n              if (this._currentDocumentRequestCancellationTokenSource) {\n                // there is already a request running,\n                this._providersChangedDuringRequest = true;\n                return;\n              }\n              this._fetchDocumentSemanticTokens.schedule(0);\n            }));\n          }\n        }\n      };\n      bindDocumentChangeListeners();\n      this._register(this._provider.onDidChange(() => {\n        bindDocumentChangeListeners();\n        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n      }));\n      this._register(themeService.onDidColorThemeChange(_ => {\n        // clear out existing tokens\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n      }));\n      this._fetchDocumentSemanticTokens.schedule(0);\n    }\n    dispose() {\n      if (this._currentDocumentResponse) {\n        this._currentDocumentResponse.dispose();\n        this._currentDocumentResponse = null;\n      }\n      if (this._currentDocumentRequestCancellationTokenSource) {\n        this._currentDocumentRequestCancellationTokenSource.cancel();\n        this._currentDocumentRequestCancellationTokenSource = null;\n      }\n      dispose(this._documentProvidersChangeListeners);\n      this._documentProvidersChangeListeners = [];\n      this._setDocumentSemanticTokens(null, null, null, []);\n      this._isDisposed = true;\n      super.dispose();\n    }\n    _fetchDocumentSemanticTokensNow() {\n      if (this._currentDocumentRequestCancellationTokenSource) {\n        // there is already a request running, let it finish...\n        return;\n      }\n      if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {\n        // there is no provider\n        if (this._currentDocumentResponse) {\n          // there are semantic tokens set\n          this._model.tokenization.setSemanticTokens(null, false);\n        }\n        return;\n      }\n      if (!this._model.isAttachedToEditor()) {\n        // this document is not visible, there is no need to fetch semantic tokens for it\n        return;\n      }\n      const cancellationTokenSource = new CancellationTokenSource();\n      const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;\n      const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;\n      const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);\n      this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;\n      this._providersChangedDuringRequest = false;\n      const pendingChanges = [];\n      const contentChangeListener = this._model.onDidChangeContent(e => {\n        pendingChanges.push(e);\n      });\n      const sw = new StopWatch(false);\n      request.then(res => {\n        this._debounceInformation.update(this._model, sw.elapsed());\n        this._currentDocumentRequestCancellationTokenSource = null;\n        contentChangeListener.dispose();\n        if (!res) {\n          this._setDocumentSemanticTokens(null, null, null, pendingChanges);\n        } else {\n          const {\n            provider,\n            tokens\n          } = res;\n          const styling = this._semanticTokensStylingService.getStyling(provider);\n          this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);\n        }\n      }, err => {\n        const isExpectedError = err && (errors.isCancellationError(err) || typeof err.message === 'string' && err.message.indexOf('busy') !== -1);\n        if (!isExpectedError) {\n          errors.onUnexpectedError(err);\n        }\n        // Semantic tokens eats up all errors and considers errors to mean that the result is temporarily not available\n        // The API does not have a special error kind to express this...\n        this._currentDocumentRequestCancellationTokenSource = null;\n        contentChangeListener.dispose();\n        if (pendingChanges.length > 0 || this._providersChangedDuringRequest) {\n          // More changes occurred while the request was running\n          if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n          }\n        }\n      });\n    }\n    static _copy(src, srcOffset, dest, destOffset, length) {\n      // protect against overflows\n      length = Math.min(length, dest.length - destOffset, src.length - srcOffset);\n      for (let i = 0; i < length; i++) {\n        dest[destOffset + i] = src[srcOffset + i];\n      }\n    }\n    _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {\n      const currentResponse = this._currentDocumentResponse;\n      const rescheduleIfNeeded = () => {\n        if ((pendingChanges.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled()) {\n          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }\n      };\n      if (this._currentDocumentResponse) {\n        this._currentDocumentResponse.dispose();\n        this._currentDocumentResponse = null;\n      }\n      if (this._isDisposed) {\n        // disposed!\n        if (provider && tokens) {\n          provider.releaseDocumentSemanticTokens(tokens.resultId);\n        }\n        return;\n      }\n      if (!provider || !styling) {\n        this._model.tokenization.setSemanticTokens(null, false);\n        return;\n      }\n      if (!tokens) {\n        this._model.tokenization.setSemanticTokens(null, true);\n        rescheduleIfNeeded();\n        return;\n      }\n      if (isSemanticTokensEdits(tokens)) {\n        if (!currentResponse) {\n          // not possible!\n          this._model.tokenization.setSemanticTokens(null, true);\n          return;\n        }\n        if (tokens.edits.length === 0) {\n          // nothing to do!\n          tokens = {\n            resultId: tokens.resultId,\n            data: currentResponse.data\n          };\n        } else {\n          let deltaLength = 0;\n          for (const edit of tokens.edits) {\n            deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;\n          }\n          const srcData = currentResponse.data;\n          const destData = new Uint32Array(srcData.length + deltaLength);\n          let srcLastStart = srcData.length;\n          let destLastStart = destData.length;\n          for (let i = tokens.edits.length - 1; i >= 0; i--) {\n            const edit = tokens.edits[i];\n            if (edit.start > srcData.length) {\n              styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i, edit.start, srcData.length);\n              // The edits are invalid and there's no way to recover\n              this._model.tokenization.setSemanticTokens(null, true);\n              return;\n            }\n            const copyCount = srcLastStart - (edit.start + edit.deleteCount);\n            if (copyCount > 0) {\n              ModelSemanticColoring_1._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);\n              destLastStart -= copyCount;\n            }\n            if (edit.data) {\n              ModelSemanticColoring_1._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);\n              destLastStart -= edit.data.length;\n            }\n            srcLastStart = edit.start;\n          }\n          if (srcLastStart > 0) {\n            ModelSemanticColoring_1._copy(srcData, 0, destData, 0, srcLastStart);\n          }\n          tokens = {\n            resultId: tokens.resultId,\n            data: destData\n          };\n        }\n      }\n      if (isSemanticTokens(tokens)) {\n        this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);\n        const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());\n        // Adjust incoming semantic tokens\n        if (pendingChanges.length > 0) {\n          // More changes occurred while the request was running\n          // We need to:\n          // 1. Adjust incoming semantic tokens\n          // 2. Request them again\n          for (const change of pendingChanges) {\n            for (const area of result) {\n              for (const singleChange of change.changes) {\n                area.applyEdit(singleChange.range, singleChange.text);\n              }\n            }\n          }\n        }\n        this._model.tokenization.setSemanticTokens(result, true);\n      } else {\n        this._model.tokenization.setSemanticTokens(null, true);\n      }\n      rescheduleIfNeeded();\n    }\n  };\n  return ModelSemanticColoring;\n})();\nModelSemanticColoring = ModelSemanticColoring_1 = __decorate([__param(1, ISemanticTokensStylingService), __param(2, IThemeService), __param(3, ILanguageFeatureDebounceService), __param(4, ILanguageFeaturesService)], ModelSemanticColoring);\nclass SemanticTokensResponse {\n  constructor(provider, resultId, data) {\n    this.provider = provider;\n    this.resultId = resultId;\n    this.data = data;\n  }\n  dispose() {\n    this.provider.releaseDocumentSemanticTokens(this.resultId);\n  }\n}\nregisterEditorFeature(DocumentSemanticTokensFeature);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ModelSemanticColoring_1","Disposable","dispose","errors","IModelService","IConfigurationService","RunOnceScheduler","CancellationTokenSource","IThemeService","toMultilineTokens2","getDocumentSemanticTokens","hasDocumentSemanticTokensProvider","isSemanticTokens","isSemanticTokensEdits","ILanguageFeatureDebounceService","StopWatch","ILanguageFeaturesService","ISemanticTokensStylingService","registerEditorFeature","SEMANTIC_HIGHLIGHTING_SETTING_ID","isSemanticColoringEnabled","DocumentSemanticTokensFeature","constructor","semanticTokensStylingService","modelService","themeService","configurationService","languageFeatureDebounceService","languageFeaturesService","_watchers","create","register","model","uri","toString","ModelSemanticColoring","deregister","modelSemanticColoring","handleSettingOrThemeChange","getModels","curr","forEach","_register","onModelAdded","onModelRemoved","onDidChangeConfiguration","e","affectsConfiguration","onDidColorThemeChange","watcher","values","_","_2","REQUEST_MIN_DELAY","_3","REQUEST_MAX_DELAY","_semanticTokensStylingService","_isDisposed","_model","_provider","documentSemanticTokensProvider","_debounceInformation","for","min","max","_fetchDocumentSemanticTokens","_fetchDocumentSemanticTokensNow","_currentDocumentResponse","_currentDocumentRequestCancellationTokenSource","_documentProvidersChangeListeners","_providersChangedDuringRequest","onDidChangeContent","isScheduled","schedule","get","onDidChangeAttached","onDidChangeLanguage","cancel","_setDocumentSemanticTokens","bindDocumentChangeListeners","provider","all","onDidChange","push","tokenization","setSemanticTokens","isAttachedToEditor","cancellationTokenSource","lastProvider","lastResultId","resultId","request","token","pendingChanges","contentChangeListener","sw","then","res","update","elapsed","tokens","styling","getStyling","err","isExpectedError","isCancellationError","message","indexOf","onUnexpectedError","_copy","src","srcOffset","dest","destOffset","Math","currentResponse","rescheduleIfNeeded","releaseDocumentSemanticTokens","edits","data","deltaLength","edit","deleteCount","srcData","destData","Uint32Array","srcLastStart","destLastStart","start","warnInvalidEditStart","copyCount","SemanticTokensResponse","result","getLanguageId","change","area","singleChange","changes","applyEdit","range","text"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelSemanticColoring_1;\nimport { Disposable, dispose } from '../../../../base/common/lifecycle.js';\nimport * as errors from '../../../../base/common/errors.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { toMultilineTokens2 } from '../../../common/services/semanticTokensProviderStyling.js';\nimport { getDocumentSemanticTokens, hasDocumentSemanticTokensProvider, isSemanticTokens, isSemanticTokensEdits } from '../common/getSemanticTokens.js';\nimport { ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ISemanticTokensStylingService } from '../../../common/services/semanticTokensStyling.js';\nimport { registerEditorFeature } from '../../../common/editorFeatures.js';\nimport { SEMANTIC_HIGHLIGHTING_SETTING_ID, isSemanticColoringEnabled } from '../common/semanticTokensConfig.js';\nlet DocumentSemanticTokensFeature = class DocumentSemanticTokensFeature extends Disposable {\n    constructor(semanticTokensStylingService, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._watchers = Object.create(null);\n        const register = (model) => {\n            this._watchers[model.uri.toString()] = new ModelSemanticColoring(model, semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService);\n        };\n        const deregister = (model, modelSemanticColoring) => {\n            modelSemanticColoring.dispose();\n            delete this._watchers[model.uri.toString()];\n        };\n        const handleSettingOrThemeChange = () => {\n            for (const model of modelService.getModels()) {\n                const curr = this._watchers[model.uri.toString()];\n                if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                    if (!curr) {\n                        register(model);\n                    }\n                }\n                else {\n                    if (curr) {\n                        deregister(model, curr);\n                    }\n                }\n            }\n        };\n        modelService.getModels().forEach(model => {\n            if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                register(model);\n            }\n        });\n        this._register(modelService.onModelAdded((model) => {\n            if (isSemanticColoringEnabled(model, themeService, configurationService)) {\n                register(model);\n            }\n        }));\n        this._register(modelService.onModelRemoved((model) => {\n            const curr = this._watchers[model.uri.toString()];\n            if (curr) {\n                deregister(model, curr);\n            }\n        }));\n        this._register(configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {\n                handleSettingOrThemeChange();\n            }\n        }));\n        this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));\n    }\n    dispose() {\n        // Dispose all watchers\n        for (const watcher of Object.values(this._watchers)) {\n            watcher.dispose();\n        }\n        super.dispose();\n    }\n};\nDocumentSemanticTokensFeature = __decorate([\n    __param(0, ISemanticTokensStylingService),\n    __param(1, IModelService),\n    __param(2, IThemeService),\n    __param(3, IConfigurationService),\n    __param(4, ILanguageFeatureDebounceService),\n    __param(5, ILanguageFeaturesService)\n], DocumentSemanticTokensFeature);\nexport { DocumentSemanticTokensFeature };\nlet ModelSemanticColoring = class ModelSemanticColoring extends Disposable {\n    static { ModelSemanticColoring_1 = this; }\n    static { this.REQUEST_MIN_DELAY = 300; }\n    static { this.REQUEST_MAX_DELAY = 2000; }\n    constructor(model, _semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService) {\n        super();\n        this._semanticTokensStylingService = _semanticTokensStylingService;\n        this._isDisposed = false;\n        this._model = model;\n        this._provider = languageFeaturesService.documentSemanticTokensProvider;\n        this._debounceInformation = languageFeatureDebounceService.for(this._provider, 'DocumentSemanticTokens', { min: ModelSemanticColoring_1.REQUEST_MIN_DELAY, max: ModelSemanticColoring_1.REQUEST_MAX_DELAY });\n        this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring_1.REQUEST_MIN_DELAY));\n        this._currentDocumentResponse = null;\n        this._currentDocumentRequestCancellationTokenSource = null;\n        this._documentProvidersChangeListeners = [];\n        this._providersChangedDuringRequest = false;\n        this._register(this._model.onDidChangeContent(() => {\n            if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        }));\n        this._register(this._model.onDidChangeAttached(() => {\n            if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        }));\n        this._register(this._model.onDidChangeLanguage(() => {\n            // clear any outstanding state\n            if (this._currentDocumentResponse) {\n                this._currentDocumentResponse.dispose();\n                this._currentDocumentResponse = null;\n            }\n            if (this._currentDocumentRequestCancellationTokenSource) {\n                this._currentDocumentRequestCancellationTokenSource.cancel();\n                this._currentDocumentRequestCancellationTokenSource = null;\n            }\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(0);\n        }));\n        const bindDocumentChangeListeners = () => {\n            dispose(this._documentProvidersChangeListeners);\n            this._documentProvidersChangeListeners = [];\n            for (const provider of this._provider.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    this._documentProvidersChangeListeners.push(provider.onDidChange(() => {\n                        if (this._currentDocumentRequestCancellationTokenSource) {\n                            // there is already a request running,\n                            this._providersChangedDuringRequest = true;\n                            return;\n                        }\n                        this._fetchDocumentSemanticTokens.schedule(0);\n                    }));\n                }\n            }\n        };\n        bindDocumentChangeListeners();\n        this._register(this._provider.onDidChange(() => {\n            bindDocumentChangeListeners();\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._register(themeService.onDidColorThemeChange(_ => {\n            // clear out existing tokens\n            this._setDocumentSemanticTokens(null, null, null, []);\n            this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n        }));\n        this._fetchDocumentSemanticTokens.schedule(0);\n    }\n    dispose() {\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            this._currentDocumentRequestCancellationTokenSource.cancel();\n            this._currentDocumentRequestCancellationTokenSource = null;\n        }\n        dispose(this._documentProvidersChangeListeners);\n        this._documentProvidersChangeListeners = [];\n        this._setDocumentSemanticTokens(null, null, null, []);\n        this._isDisposed = true;\n        super.dispose();\n    }\n    _fetchDocumentSemanticTokensNow() {\n        if (this._currentDocumentRequestCancellationTokenSource) {\n            // there is already a request running, let it finish...\n            return;\n        }\n        if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {\n            // there is no provider\n            if (this._currentDocumentResponse) {\n                // there are semantic tokens set\n                this._model.tokenization.setSemanticTokens(null, false);\n            }\n            return;\n        }\n        if (!this._model.isAttachedToEditor()) {\n            // this document is not visible, there is no need to fetch semantic tokens for it\n            return;\n        }\n        const cancellationTokenSource = new CancellationTokenSource();\n        const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;\n        const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;\n        const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);\n        this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;\n        this._providersChangedDuringRequest = false;\n        const pendingChanges = [];\n        const contentChangeListener = this._model.onDidChangeContent((e) => {\n            pendingChanges.push(e);\n        });\n        const sw = new StopWatch(false);\n        request.then((res) => {\n            this._debounceInformation.update(this._model, sw.elapsed());\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (!res) {\n                this._setDocumentSemanticTokens(null, null, null, pendingChanges);\n            }\n            else {\n                const { provider, tokens } = res;\n                const styling = this._semanticTokensStylingService.getStyling(provider);\n                this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);\n            }\n        }, (err) => {\n            const isExpectedError = err && (errors.isCancellationError(err) || (typeof err.message === 'string' && err.message.indexOf('busy') !== -1));\n            if (!isExpectedError) {\n                errors.onUnexpectedError(err);\n            }\n            // Semantic tokens eats up all errors and considers errors to mean that the result is temporarily not available\n            // The API does not have a special error kind to express this...\n            this._currentDocumentRequestCancellationTokenSource = null;\n            contentChangeListener.dispose();\n            if (pendingChanges.length > 0 || this._providersChangedDuringRequest) {\n                // More changes occurred while the request was running\n                if (!this._fetchDocumentSemanticTokens.isScheduled()) {\n                    this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n                }\n            }\n        });\n    }\n    static _copy(src, srcOffset, dest, destOffset, length) {\n        // protect against overflows\n        length = Math.min(length, dest.length - destOffset, src.length - srcOffset);\n        for (let i = 0; i < length; i++) {\n            dest[destOffset + i] = src[srcOffset + i];\n        }\n    }\n    _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {\n        const currentResponse = this._currentDocumentResponse;\n        const rescheduleIfNeeded = () => {\n            if ((pendingChanges.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled()) {\n                this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));\n            }\n        };\n        if (this._currentDocumentResponse) {\n            this._currentDocumentResponse.dispose();\n            this._currentDocumentResponse = null;\n        }\n        if (this._isDisposed) {\n            // disposed!\n            if (provider && tokens) {\n                provider.releaseDocumentSemanticTokens(tokens.resultId);\n            }\n            return;\n        }\n        if (!provider || !styling) {\n            this._model.tokenization.setSemanticTokens(null, false);\n            return;\n        }\n        if (!tokens) {\n            this._model.tokenization.setSemanticTokens(null, true);\n            rescheduleIfNeeded();\n            return;\n        }\n        if (isSemanticTokensEdits(tokens)) {\n            if (!currentResponse) {\n                // not possible!\n                this._model.tokenization.setSemanticTokens(null, true);\n                return;\n            }\n            if (tokens.edits.length === 0) {\n                // nothing to do!\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: currentResponse.data\n                };\n            }\n            else {\n                let deltaLength = 0;\n                for (const edit of tokens.edits) {\n                    deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;\n                }\n                const srcData = currentResponse.data;\n                const destData = new Uint32Array(srcData.length + deltaLength);\n                let srcLastStart = srcData.length;\n                let destLastStart = destData.length;\n                for (let i = tokens.edits.length - 1; i >= 0; i--) {\n                    const edit = tokens.edits[i];\n                    if (edit.start > srcData.length) {\n                        styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i, edit.start, srcData.length);\n                        // The edits are invalid and there's no way to recover\n                        this._model.tokenization.setSemanticTokens(null, true);\n                        return;\n                    }\n                    const copyCount = srcLastStart - (edit.start + edit.deleteCount);\n                    if (copyCount > 0) {\n                        ModelSemanticColoring_1._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);\n                        destLastStart -= copyCount;\n                    }\n                    if (edit.data) {\n                        ModelSemanticColoring_1._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);\n                        destLastStart -= edit.data.length;\n                    }\n                    srcLastStart = edit.start;\n                }\n                if (srcLastStart > 0) {\n                    ModelSemanticColoring_1._copy(srcData, 0, destData, 0, srcLastStart);\n                }\n                tokens = {\n                    resultId: tokens.resultId,\n                    data: destData\n                };\n            }\n        }\n        if (isSemanticTokens(tokens)) {\n            this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);\n            const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());\n            // Adjust incoming semantic tokens\n            if (pendingChanges.length > 0) {\n                // More changes occurred while the request was running\n                // We need to:\n                // 1. Adjust incoming semantic tokens\n                // 2. Request them again\n                for (const change of pendingChanges) {\n                    for (const area of result) {\n                        for (const singleChange of change.changes) {\n                            area.applyEdit(singleChange.range, singleChange.text);\n                        }\n                    }\n                }\n            }\n            this._model.tokenization.setSemanticTokens(result, true);\n        }\n        else {\n            this._model.tokenization.setSemanticTokens(null, true);\n        }\n        rescheduleIfNeeded();\n    }\n};\nModelSemanticColoring = ModelSemanticColoring_1 = __decorate([\n    __param(1, ISemanticTokensStylingService),\n    __param(2, IThemeService),\n    __param(3, ILanguageFeatureDebounceService),\n    __param(4, ILanguageFeaturesService)\n], ModelSemanticColoring);\nclass SemanticTokensResponse {\n    constructor(provider, resultId, data) {\n        this.provider = provider;\n        this.resultId = resultId;\n        this.data = data;\n    }\n    dispose() {\n        this.provider.releaseDocumentSemanticTokens(this.resultId);\n    }\n}\nregisterEditorFeature(DocumentSemanticTokensFeature);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}