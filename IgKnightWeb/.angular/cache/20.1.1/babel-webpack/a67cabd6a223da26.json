{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  static #_ = AbstractGotoSymbolQuickAccessProvider_1 = this;\n  static #_2 = this.PREFIX = '@';\n  static #_3 = this.SCOPE_PREFIX = ':';\n  static #_4 = this.PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`;\n  constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n    super(options);\n    this._languageFeaturesService = _languageFeaturesService;\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token, runOptions) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    var _this = this;\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    _asyncToGenerator(function* () {\n      const result = yield _this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(_this.doProvideWithEditorSymbols(context, model, picker, token));\n    })();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* SymbolKind.String */\n    }];\n    picker.ariaLabel = label;\n  }\n  waitForLanguageSymbolRegistry(model, disposables) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2._languageFeaturesService.documentSymbolProvider.has(model)) {\n        return true;\n      }\n      const symbolProviderRegistryPromise = new DeferredPromise();\n      // Resolve promise when registry knows model\n      const symbolProviderListener = disposables.add(_this2._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n        if (_this2._languageFeaturesService.documentSymbolProvider.has(model)) {\n          symbolProviderListener.dispose();\n          symbolProviderRegistryPromise.complete(true);\n        }\n      }));\n      // Resolve promise when we get disposed too\n      disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n      return symbolProviderRegistryPromise.p;\n    })();\n  }\n  doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n    var _this3 = this;\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        runOptions?.handleAccept?.(item);\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(({\n      item\n    }) => {\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (positionToEnclose) {\n        // Cancel any previous ask for picks and busy\n        picksCts?.dispose(true);\n        picker.busy = false;\n        // Create new cancellation source for this run\n        picksCts = new CancellationTokenSource(token);\n        // Collect symbol picks\n        picker.busy = true;\n        try {\n          const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n          const items = yield _this3.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n          if (token.isCancellationRequested) {\n            return;\n          }\n          if (items.length > 0) {\n            picker.items = items;\n            if (positionToEnclose && query.original.length === 0) {\n              const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n              if (candidate) {\n                picker.activeItems = [candidate];\n              }\n            }\n          } else {\n            if (query.original.length > 0) {\n              _this3.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n            } else {\n              _this3.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n            }\n          }\n        } finally {\n          if (!token.isCancellationRequested) {\n            picker.busy = false;\n          }\n        }\n      });\n      return function updatePickerItems(_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n    updatePickerItems(editor.getSelection()?.getPosition());\n    // Reveal and decorate when active item changes\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const symbols = yield symbolsPromise;\n      if (token.isCancellationRequested) {\n        return [];\n      }\n      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n      const filterPos = filterBySymbolKind ? 1 : 0;\n      // Split between symbol and container query\n      let symbolQuery;\n      let containerQuery;\n      if (query.values && query.values.length > 1) {\n        symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n        containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n      } else {\n        symbolQuery = query;\n      }\n      // Convert to symbol picks and apply filtering\n      let buttons;\n      const openSideBySideDirection = _this4.options?.openSideBySideDirection?.();\n      if (openSideBySideDirection) {\n        buttons = [{\n          iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n          tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n        }];\n      }\n      const filteredSymbolPicks = [];\n      for (let index = 0; index < symbols.length; index++) {\n        const symbol = symbols[index];\n        const symbolLabel = trim(symbol.name);\n        const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n        let containerLabel = symbol.containerName;\n        if (options?.extraContainerLabel) {\n          if (containerLabel) {\n            containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n          } else {\n            containerLabel = options.extraContainerLabel;\n          }\n        }\n        let symbolScore = undefined;\n        let symbolMatches = undefined;\n        let containerScore = undefined;\n        let containerMatches = undefined;\n        if (query.original.length > filterPos) {\n          // First: try to score on the entire query, it is possible that\n          // the symbol matches perfectly (e.g. searching for \"change log\"\n          // can be a match on a markdown symbol \"change log\"). In that\n          // case we want to skip the container query altogether.\n          let skipContainerQuery = false;\n          if (symbolQuery !== query) {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, {\n              ...query,\n              values: undefined /* disable multi-query support */\n            }, filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore === 'number') {\n              skipContainerQuery = true; // since we consumed the query, skip any container matching\n            }\n          }\n          // Otherwise: score on the symbol query and match on the container later\n          if (typeof symbolScore !== 'number') {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore !== 'number') {\n              continue;\n            }\n          }\n          // Score by container if specified\n          if (!skipContainerQuery && containerQuery) {\n            if (containerLabel && containerQuery.original.length > 0) {\n              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n            }\n            if (typeof containerScore !== 'number') {\n              continue;\n            }\n            if (typeof symbolScore === 'number') {\n              symbolScore += containerScore; // boost symbolScore by containerScore\n            }\n          }\n        }\n        const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n        filteredSymbolPicks.push({\n          index,\n          kind: symbol.kind,\n          score: symbolScore,\n          label: symbolLabelWithIcon,\n          ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n          description: containerLabel,\n          highlights: deprecated ? undefined : {\n            label: symbolMatches,\n            description: containerMatches\n          },\n          range: {\n            selection: Range.collapseToStart(symbol.selectionRange),\n            decoration: symbol.range\n          },\n          uri: model.uri,\n          symbolName: symbolLabel,\n          strikethrough: deprecated,\n          buttons\n        });\n      }\n      // Sort by score\n      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? _this4.compareByKindAndScore(symbolA, symbolB) : _this4.compareByScore(symbolA, symbolB));\n      // Add separator for types\n      // - @  only total number of symbols\n      // - @: grouped by symbol kind\n      let symbolPicks = [];\n      if (filterBySymbolKind) {\n        let lastSymbolKind = undefined;\n        let lastSeparator = undefined;\n        let lastSymbolKindCounter = 0;\n        function updateLastSeparatorLabel() {\n          if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n          }\n        }\n        for (const symbolPick of sortedFilteredSymbolPicks) {\n          // Found new kind\n          if (lastSymbolKind !== symbolPick.kind) {\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n            lastSymbolKind = symbolPick.kind;\n            lastSymbolKindCounter = 1;\n            // Add new separator for new kind\n            lastSeparator = {\n              type: 'separator'\n            };\n            symbolPicks.push(lastSeparator);\n          }\n          // Existing kind, keep counting\n          else {\n            lastSymbolKindCounter++;\n          }\n          // Add to final result\n          symbolPicks.push(symbolPick);\n        }\n        // Update last separator with number of symbols we found for kind\n        updateLastSeparatorLabel();\n      } else if (sortedFilteredSymbolPicks.length > 0) {\n        symbolPicks = [{\n          label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n          type: 'separator'\n        }, ...sortedFilteredSymbolPicks];\n      }\n      return symbolPicks;\n    })();\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  getDocumentSymbols(document, token) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const model = yield _this5._outlineModelService.getOrCreate(document, token);\n      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    })();\n  }\n};\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([__param(0, ILanguageFeaturesService), __param(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n  [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n  [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n  [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n  [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n  [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n  [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n  [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n  [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n  [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n  [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n  [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","AbstractGotoSymbolQuickAccessProvider_1","DeferredPromise","CancellationTokenSource","Codicon","ThemeIcon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","SymbolKinds","getAriaLabelForSymbol","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","ILanguageFeaturesService","findLast","AbstractGotoSymbolQuickAccessProvider","_","_2","PREFIX","_3","SCOPE_PREFIX","_4","PREFIX_BY_CATEGORY","constructor","_languageFeaturesService","_outlineModelService","options","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","runOptions","editor","model","getModel","documentSymbolProvider","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","_this","disposables","_asyncToGenerator","result","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","_this2","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","_this3","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","handleAccept","hide","onDidTriggerItemButton","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","undefined","updatePickerItems","_ref2","positionToEnclose","busy","query","value","substr","doGetSymbolPicks","original","candidate","Boolean","type","containsPosition","decoration","activeItems","_x","apply","onDidChangeValue","getSelection","getPosition","onDidChangeActive","revealRangeInCenter","addDecorations","_this4","symbols","filterBySymbolKind","indexOf","filterPos","symbolQuery","containerQuery","values","slice","buttons","openSideBySideDirection","iconClass","asClassName","splitHorizontal","splitVertical","tooltip","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","uri","symbolName","strikethrough","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","localeCompare","document","_this5","getOrCreate","asListOfDocumentSymbols"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    static { AbstractGotoSymbolQuickAccessProvider_1 = this; }\n    static { this.PREFIX = '@'; }\n    static { this.SCOPE_PREFIX = ':'; }\n    static { this.PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`; }\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token, runOptions) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (async () => {\n            const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        })();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];\n        picker.ariaLabel = label;\n    }\n    async waitForLanguageSymbolRegistry(model, disposables) {\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return true;\n        }\n        const symbolProviderRegistryPromise = new DeferredPromise();\n        // Resolve promise when registry knows model\n        const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                symbolProviderListener.dispose();\n                symbolProviderRegistryPromise.complete(true);\n            }\n        }));\n        // Resolve promise when we get disposed too\n        disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n        return symbolProviderRegistryPromise.p;\n    }\n    doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                runOptions?.handleAccept?.(item);\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = async (positionToEnclose) => {\n            // Cancel any previous ask for picks and busy\n            picksCts?.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n                const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                    if (positionToEnclose && query.original.length === 0) {\n                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n                        if (candidate) {\n                            picker.activeItems = [candidate];\n                        }\n                    }\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        };\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n        updatePickerItems(editor.getSelection()?.getPosition());\n        // Reveal and decorate when active item changes\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n        const symbols = await symbolsPromise;\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n        const filterPos = filterBySymbolKind ? 1 : 0;\n        // Split between symbol and container query\n        let symbolQuery;\n        let containerQuery;\n        if (query.values && query.values.length > 1) {\n            symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n            containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n        }\n        else {\n            symbolQuery = query;\n        }\n        // Convert to symbol picks and apply filtering\n        let buttons;\n        const openSideBySideDirection = this.options?.openSideBySideDirection?.();\n        if (openSideBySideDirection) {\n            buttons = [{\n                    iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n                    tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                }];\n        }\n        const filteredSymbolPicks = [];\n        for (let index = 0; index < symbols.length; index++) {\n            const symbol = symbols[index];\n            const symbolLabel = trim(symbol.name);\n            const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n            let containerLabel = symbol.containerName;\n            if (options?.extraContainerLabel) {\n                if (containerLabel) {\n                    containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                }\n                else {\n                    containerLabel = options.extraContainerLabel;\n                }\n            }\n            let symbolScore = undefined;\n            let symbolMatches = undefined;\n            let containerScore = undefined;\n            let containerMatches = undefined;\n            if (query.original.length > filterPos) {\n                // First: try to score on the entire query, it is possible that\n                // the symbol matches perfectly (e.g. searching for \"change log\"\n                // can be a match on a markdown symbol \"change log\"). In that\n                // case we want to skip the container query altogether.\n                let skipContainerQuery = false;\n                if (symbolQuery !== query) {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, { ...query, values: undefined /* disable multi-query support */ }, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore === 'number') {\n                        skipContainerQuery = true; // since we consumed the query, skip any container matching\n                    }\n                }\n                // Otherwise: score on the symbol query and match on the container later\n                if (typeof symbolScore !== 'number') {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore !== 'number') {\n                        continue;\n                    }\n                }\n                // Score by container if specified\n                if (!skipContainerQuery && containerQuery) {\n                    if (containerLabel && containerQuery.original.length > 0) {\n                        [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                    }\n                    if (typeof containerScore !== 'number') {\n                        continue;\n                    }\n                    if (typeof symbolScore === 'number') {\n                        symbolScore += containerScore; // boost symbolScore by containerScore\n                    }\n                }\n            }\n            const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n            filteredSymbolPicks.push({\n                index,\n                kind: symbol.kind,\n                score: symbolScore,\n                label: symbolLabelWithIcon,\n                ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n                description: containerLabel,\n                highlights: deprecated ? undefined : {\n                    label: symbolMatches,\n                    description: containerMatches\n                },\n                range: {\n                    selection: Range.collapseToStart(symbol.selectionRange),\n                    decoration: symbol.range\n                },\n                uri: model.uri,\n                symbolName: symbolLabel,\n                strikethrough: deprecated,\n                buttons\n            });\n        }\n        // Sort by score\n        const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n            this.compareByKindAndScore(symbolA, symbolB) :\n            this.compareByScore(symbolA, symbolB));\n        // Add separator for types\n        // - @  only total number of symbols\n        // - @: grouped by symbol kind\n        let symbolPicks = [];\n        if (filterBySymbolKind) {\n            let lastSymbolKind = undefined;\n            let lastSeparator = undefined;\n            let lastSymbolKindCounter = 0;\n            function updateLastSeparatorLabel() {\n                if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                    lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                }\n            }\n            for (const symbolPick of sortedFilteredSymbolPicks) {\n                // Found new kind\n                if (lastSymbolKind !== symbolPick.kind) {\n                    // Update last separator with number of symbols we found for kind\n                    updateLastSeparatorLabel();\n                    lastSymbolKind = symbolPick.kind;\n                    lastSymbolKindCounter = 1;\n                    // Add new separator for new kind\n                    lastSeparator = { type: 'separator' };\n                    symbolPicks.push(lastSeparator);\n                }\n                // Existing kind, keep counting\n                else {\n                    lastSymbolKindCounter++;\n                }\n                // Add to final result\n                symbolPicks.push(symbolPick);\n            }\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n        }\n        else if (sortedFilteredSymbolPicks.length > 0) {\n            symbolPicks = [\n                { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                ...sortedFilteredSymbolPicks\n            ];\n        }\n        return symbolPicks;\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    async getDocumentSymbols(document, token) {\n        const model = await this._outlineModelService.getOrCreate(document, token);\n        return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    }\n};\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n    [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n    [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n    [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n    [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n    [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n    [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n    [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n    [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n    [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n    [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}