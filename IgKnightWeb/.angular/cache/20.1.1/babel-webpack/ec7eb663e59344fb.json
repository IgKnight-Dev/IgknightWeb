{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar CopyPasteController_1;\nimport { addDisposableListener, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, DeferredPromise, raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { UriList, createStringDataTransferItem, matchesMimeType } from '../../../../base/common/dataTransfer.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../../base/common/mime.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { ClipboardEventUtils } from '../../../browser/controller/textAreaInput.js';\nimport { toExternalVSDataTransfer, toVSDataTransfer } from '../../../browser/dnd.js';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentPasteTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { DefaultTextPasteOrDropEditProvider } from './defaultProviders.js';\nimport { createCombinedWorkspaceEdit, sortEditsByYieldTo } from './edit.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport { localize } from '../../../../nls.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProgressService } from '../../../../platform/progress/common/progress.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { PostEditWidgetManager } from './postEditWidget.js';\nimport { CancellationError, isCancellationError } from '../../../../base/common/errors.js';\nexport const changePasteTypeCommandId = 'editor.changePasteType';\nexport const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localize('pasteWidgetVisible', \"Whether the paste widget is showing\"));\nconst vscodeClipboardMime = 'application/vnd.code.copyMetadata';\nlet CopyPasteController = /*#__PURE__*/(() => {\n  let CopyPasteController = class CopyPasteController extends Disposable {\n    static #_ = CopyPasteController_1 = this;\n    static #_2 = this.ID = 'editor.contrib.copyPasteActionController';\n    static get(editor) {\n      return editor.getContribution(CopyPasteController_1.ID);\n    }\n    constructor(editor, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {\n      super();\n      this._bulkEditService = _bulkEditService;\n      this._clipboardService = _clipboardService;\n      this._languageFeaturesService = _languageFeaturesService;\n      this._quickInputService = _quickInputService;\n      this._progressService = _progressService;\n      this._editor = editor;\n      const container = editor.getContainerDomNode();\n      this._register(addDisposableListener(container, 'copy', e => this.handleCopy(e)));\n      this._register(addDisposableListener(container, 'cut', e => this.handleCopy(e)));\n      this._register(addDisposableListener(container, 'paste', e => this.handlePaste(e), true));\n      this._pasteProgressManager = this._register(new InlineProgressManager('pasteIntoEditor', editor, instantiationService));\n      this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, {\n        id: changePasteTypeCommandId,\n        label: localize('postPasteWidgetTitle', \"Show paste options...\")\n      }));\n    }\n    changePasteType() {\n      this._postPasteWidgetManager.tryShowSelector();\n    }\n    pasteAs(preferred) {\n      this._editor.focus();\n      try {\n        this._pasteAsActionContext = {\n          preferred\n        };\n        getActiveDocument().execCommand('paste');\n      } finally {\n        this._pasteAsActionContext = undefined;\n      }\n    }\n    clearWidgets() {\n      this._postPasteWidgetManager.clear();\n    }\n    isPasteAsEnabled() {\n      return this._editor.getOption(85 /* EditorOption.pasteAs */).enabled;\n    }\n    finishedPaste() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        yield _this._currentPasteOperation;\n      })();\n    }\n    handleCopy(e) {\n      if (!this._editor.hasTextFocus()) {\n        return;\n      }\n      // Explicitly clear the clipboard internal state.\n      // This is needed because on web, the browser clipboard is faked out using an in-memory store.\n      // This means the resources clipboard is not properly updated when copying from the editor.\n      this._clipboardService.clearInternalState?.();\n      if (!e.clipboardData || !this.isPasteAsEnabled()) {\n        return;\n      }\n      const model = this._editor.getModel();\n      const selections = this._editor.getSelections();\n      if (!model || !selections?.length) {\n        return;\n      }\n      const enableEmptySelectionClipboard = this._editor.getOption(37 /* EditorOption.emptySelectionClipboard */);\n      let ranges = selections;\n      const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();\n      if (wasFromEmptySelection) {\n        if (!enableEmptySelectionClipboard) {\n          return;\n        }\n        ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];\n      }\n      const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);\n      const multicursorText = Array.isArray(toCopy) ? toCopy : null;\n      const defaultPastePayload = {\n        multicursorText,\n        pasteOnNewLine: wasFromEmptySelection,\n        mode: null\n      };\n      const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter(x => !!x.prepareDocumentPaste);\n      if (!providers.length) {\n        this.setCopyMetadata(e.clipboardData, {\n          defaultPastePayload\n        });\n        return;\n      }\n      const dataTransfer = toVSDataTransfer(e.clipboardData);\n      const providerCopyMimeTypes = providers.flatMap(x => x.copyMimeTypes ?? []);\n      // Save off a handle pointing to data that VS Code maintains.\n      const handle = generateUuid();\n      this.setCopyMetadata(e.clipboardData, {\n        id: handle,\n        providerCopyMimeTypes,\n        defaultPastePayload\n      });\n      const promise = createCancelablePromise(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (token) {\n          const results = coalesce(yield Promise.all(providers.map(/*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (provider) {\n              try {\n                return yield provider.prepareDocumentPaste(model, ranges, dataTransfer, token);\n              } catch (err) {\n                console.error(err);\n                return undefined;\n              }\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }())));\n          // Values from higher priority providers should overwrite values from lower priority ones.\n          // Reverse the array to so that the calls to `replace` below will do this\n          results.reverse();\n          for (const result of results) {\n            for (const [mime, value] of result) {\n              dataTransfer.replace(mime, value);\n            }\n          }\n          return dataTransfer;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      CopyPasteController_1._currentCopyOperation?.dataTransferPromise.cancel();\n      CopyPasteController_1._currentCopyOperation = {\n        handle: handle,\n        dataTransferPromise: promise\n      };\n    }\n    handlePaste(e) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!e.clipboardData || !_this2._editor.hasTextFocus()) {\n          return;\n        }\n        MessageController.get(_this2._editor)?.closeMessage();\n        _this2._currentPasteOperation?.cancel();\n        _this2._currentPasteOperation = undefined;\n        const model = _this2._editor.getModel();\n        const selections = _this2._editor.getSelections();\n        if (!selections?.length || !model) {\n          return;\n        }\n        if (_this2._editor.getOption(92 /* EditorOption.readOnly */) // Never enabled if editor is readonly.\n        || !_this2.isPasteAsEnabled() && !_this2._pasteAsActionContext // Or feature disabled (but still enable if paste was explicitly requested)\n        ) {\n          return;\n        }\n        const metadata = _this2.fetchCopyMetadata(e);\n        const dataTransfer = toExternalVSDataTransfer(e.clipboardData);\n        dataTransfer.delete(vscodeClipboardMime);\n        const allPotentialMimeTypes = [...e.clipboardData.types, ...(metadata?.providerCopyMimeTypes ?? []),\n        // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.\n        // However we can only check the system clipboard async. For this early check, just add it in.\n        // We filter providers again once we have the final dataTransfer we will use.\n        Mimes.uriList];\n        const allProviders = _this2._languageFeaturesService.documentPasteEditProvider.ordered(model).filter(provider => {\n          // Filter out providers that don't match the requested paste types\n          const preference = _this2._pasteAsActionContext?.preferred;\n          if (preference) {\n            if (provider.providedPasteEditKinds && !_this2.providerMatchesPreference(provider, preference)) {\n              return false;\n            }\n          }\n          // And providers that don't handle any of mime types in the clipboard\n          return provider.pasteMimeTypes?.some(type => matchesMimeType(type, allPotentialMimeTypes));\n        });\n        if (!allProviders.length) {\n          if (_this2._pasteAsActionContext?.preferred) {\n            _this2.showPasteAsNoEditMessage(selections, _this2._pasteAsActionContext.preferred);\n          }\n          return;\n        }\n        // Prevent the editor's default paste handler from running.\n        // Note that after this point, we are fully responsible for handling paste.\n        // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        if (_this2._pasteAsActionContext) {\n          _this2.showPasteAsPick(_this2._pasteAsActionContext.preferred, allProviders, selections, dataTransfer, metadata);\n        } else {\n          _this2.doPasteInline(allProviders, selections, dataTransfer, metadata, e);\n        }\n      })();\n    }\n    showPasteAsNoEditMessage(selections, preference) {\n      MessageController.get(this._editor)?.showMessage(localize('pasteAsError', \"No paste edits for '{0}' found\", preference instanceof HierarchicalKind ? preference.value : preference.providerId), selections[0].getStartPosition());\n    }\n    doPasteInline(allProviders, selections, dataTransfer, metadata, clipboardEvent) {\n      var _this3 = this;\n      const editor = this._editor;\n      if (!editor.hasModel()) {\n        return;\n      }\n      const editorStateCts = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined);\n      const p = createCancelablePromise(/*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (pToken) {\n          const editor = _this3._editor;\n          if (!editor.hasModel()) {\n            return;\n          }\n          const model = editor.getModel();\n          const disposables = new DisposableStore();\n          const cts = disposables.add(new CancellationTokenSource(pToken));\n          disposables.add(editorStateCts.token.onCancellationRequested(() => cts.cancel()));\n          const token = cts.token;\n          try {\n            yield _this3.mergeInDataFromCopy(dataTransfer, metadata, token);\n            if (token.isCancellationRequested) {\n              return;\n            }\n            const supportedProviders = allProviders.filter(provider => _this3.isSupportedPasteProvider(provider, dataTransfer));\n            if (!supportedProviders.length || supportedProviders.length === 1 && supportedProviders[0] instanceof DefaultTextPasteOrDropEditProvider // Only our default text provider is active\n            ) {\n              return _this3.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n            }\n            const context = {\n              triggerKind: DocumentPasteTriggerKind.Automatic\n            };\n            const editSession = yield _this3.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, token);\n            disposables.add(editSession);\n            if (token.isCancellationRequested) {\n              return;\n            }\n            // If the only edit returned is our default text edit, use the default paste handler\n            if (editSession.edits.length === 1 && editSession.edits[0].provider instanceof DefaultTextPasteOrDropEditProvider) {\n              return _this3.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n            }\n            if (editSession.edits.length) {\n              const canShowWidget = editor.getOption(85 /* EditorOption.pasteAs */).showPasteSelector === 'afterPaste';\n              return _this3._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, {\n                activeEditIndex: 0,\n                allEdits: editSession.edits\n              }, canShowWidget, (edit, token) => {\n                return new Promise((resolve, reject) => {\n                  _asyncToGenerator(function* () {\n                    try {\n                      const resolveP = edit.provider.resolveDocumentPasteEdit?.(edit, token);\n                      const showP = new DeferredPromise();\n                      const resolved = resolveP && (yield _this3._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('resolveProcess', \"Resolving paste edit. Click to cancel\"), Promise.race([showP.p, resolveP]), {\n                        cancel: () => {\n                          showP.cancel();\n                          return reject(new CancellationError());\n                        }\n                      }, 0));\n                      if (resolved) {\n                        edit.additionalEdit = resolved.additionalEdit;\n                      }\n                      return resolve(edit);\n                    } catch (err) {\n                      return reject(err);\n                    }\n                  })();\n                });\n              }, token);\n            }\n            yield _this3.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n          } finally {\n            disposables.dispose();\n            if (_this3._currentPasteOperation === p) {\n              _this3._currentPasteOperation = undefined;\n            }\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n      this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('pasteIntoEditorProgress', \"Running paste handlers. Click to cancel and do basic paste\"), p, {\n        cancel: function () {\n          var _ref5 = _asyncToGenerator(function* () {\n            try {\n              p.cancel();\n              if (editorStateCts.token.isCancellationRequested) {\n                return;\n              }\n              yield _this3.applyDefaultPasteHandler(dataTransfer, metadata, editorStateCts.token, clipboardEvent);\n            } finally {\n              editorStateCts.dispose();\n            }\n          });\n          return function cancel() {\n            return _ref5.apply(this, arguments);\n          };\n        }()\n      }).then(() => {\n        editorStateCts.dispose();\n      });\n      this._currentPasteOperation = p;\n    }\n    showPasteAsPick(preference, allProviders, selections, dataTransfer, metadata) {\n      var _this4 = this;\n      const p = createCancelablePromise(/*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (token) {\n          const editor = _this4._editor;\n          if (!editor.hasModel()) {\n            return;\n          }\n          const model = editor.getModel();\n          const disposables = new DisposableStore();\n          const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token));\n          try {\n            yield _this4.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);\n            if (tokenSource.token.isCancellationRequested) {\n              return;\n            }\n            // Filter out any providers the don't match the full data transfer we will send them.\n            let supportedProviders = allProviders.filter(provider => _this4.isSupportedPasteProvider(provider, dataTransfer, preference));\n            if (preference) {\n              // We are looking for a specific edit\n              supportedProviders = supportedProviders.filter(provider => _this4.providerMatchesPreference(provider, preference));\n            }\n            const context = {\n              triggerKind: DocumentPasteTriggerKind.PasteAs,\n              only: preference && preference instanceof HierarchicalKind ? preference : undefined\n            };\n            let editSession = disposables.add(yield _this4.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, tokenSource.token));\n            if (tokenSource.token.isCancellationRequested) {\n              return;\n            }\n            // Filter out any edits that don't match the requested kind\n            if (preference) {\n              editSession = {\n                edits: editSession.edits.filter(edit => {\n                  if (preference instanceof HierarchicalKind) {\n                    return preference.contains(edit.kind);\n                  } else {\n                    return preference.providerId === edit.provider.id;\n                  }\n                }),\n                dispose: editSession.dispose\n              };\n            }\n            if (!editSession.edits.length) {\n              if (context.only) {\n                _this4.showPasteAsNoEditMessage(selections, context.only);\n              }\n              return;\n            }\n            let pickedEdit;\n            if (preference) {\n              pickedEdit = editSession.edits.at(0);\n            } else {\n              const selected = yield _this4._quickInputService.pick(editSession.edits.map(edit => ({\n                label: edit.title,\n                description: edit.kind?.value,\n                edit\n              })), {\n                placeHolder: localize('pasteAsPickerPlaceholder', \"Select Paste Action\")\n              });\n              pickedEdit = selected?.edit;\n            }\n            if (!pickedEdit) {\n              return;\n            }\n            const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);\n            yield _this4._bulkEditService.apply(combinedWorkspaceEdit, {\n              editor: _this4._editor\n            });\n          } finally {\n            disposables.dispose();\n            if (_this4._currentPasteOperation === p) {\n              _this4._currentPasteOperation = undefined;\n            }\n          }\n        });\n        return function (_x4) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n      this._progressService.withProgress({\n        location: 10 /* ProgressLocation.Window */,\n        title: localize('pasteAsProgress', \"Running paste handlers\")\n      }, () => p);\n    }\n    setCopyMetadata(dataTransfer, metadata) {\n      dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));\n    }\n    fetchCopyMetadata(e) {\n      if (!e.clipboardData) {\n        return;\n      }\n      // Prefer using the clipboard data we saved off\n      const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);\n      if (rawMetadata) {\n        try {\n          return JSON.parse(rawMetadata);\n        } catch {\n          return undefined;\n        }\n      }\n      // Otherwise try to extract the generic text editor metadata\n      const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n      if (metadata) {\n        return {\n          defaultPastePayload: {\n            mode: metadata.mode,\n            multicursorText: metadata.multicursorText ?? null,\n            pasteOnNewLine: !!metadata.isFromEmptySelection\n          }\n        };\n      }\n      return undefined;\n    }\n    mergeInDataFromCopy(dataTransfer, metadata, token) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        if (metadata?.id && CopyPasteController_1._currentCopyOperation?.handle === metadata.id) {\n          const toMergeDataTransfer = yield CopyPasteController_1._currentCopyOperation.dataTransferPromise;\n          if (token.isCancellationRequested) {\n            return;\n          }\n          for (const [key, value] of toMergeDataTransfer) {\n            dataTransfer.replace(key, value);\n          }\n        }\n        if (!dataTransfer.has(Mimes.uriList)) {\n          const resources = yield _this5._clipboardService.readResources();\n          if (token.isCancellationRequested) {\n            return;\n          }\n          if (resources.length) {\n            dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));\n          }\n        }\n      })();\n    }\n    getPasteEdits(providers, dataTransfer, model, selections, context, token) {\n      return _asyncToGenerator(function* () {\n        const disposables = new DisposableStore();\n        const results = yield raceCancellation(Promise.all(providers.map(/*#__PURE__*/function () {\n          var _ref7 = _asyncToGenerator(function* (provider) {\n            try {\n              const edits = yield provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, context, token);\n              if (edits) {\n                disposables.add(edits);\n              }\n              return edits?.edits?.map(edit => ({\n                ...edit,\n                provider\n              }));\n            } catch (err) {\n              if (!isCancellationError(err)) {\n                console.error(err);\n              }\n              return undefined;\n            }\n          });\n          return function (_x5) {\n            return _ref7.apply(this, arguments);\n          };\n        }())), token);\n        const edits = coalesce(results ?? []).flat().filter(edit => {\n          return !context.only || context.only.contains(edit.kind);\n        });\n        return {\n          edits: sortEditsByYieldTo(edits),\n          dispose: () => disposables.dispose()\n        };\n      })();\n    }\n    applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get('text');\n        const text = (yield textDataTransfer?.asString()) ?? '';\n        if (token.isCancellationRequested) {\n          return;\n        }\n        const payload = {\n          clipboardEvent,\n          text,\n          pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,\n          multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,\n          mode: null\n        };\n        _this6._editor.trigger('keyboard', \"paste\" /* Handler.Paste */, payload);\n      })();\n    }\n    /**\n     * Filter out providers if they:\n     * - Don't handle any of the data transfer types we have\n     * - Don't match the preferred paste kind\n     */\n    isSupportedPasteProvider(provider, dataTransfer, preference) {\n      if (!provider.pasteMimeTypes?.some(type => dataTransfer.matches(type))) {\n        return false;\n      }\n      return !preference || this.providerMatchesPreference(provider, preference);\n    }\n    providerMatchesPreference(provider, preference) {\n      if (preference instanceof HierarchicalKind) {\n        if (!provider.providedPasteEditKinds) {\n          return true;\n        }\n        return provider.providedPasteEditKinds.some(providedKind => preference.contains(providedKind));\n      } else {\n        return provider.id === preference.providerId;\n      }\n    }\n  };\n  return CopyPasteController;\n})();\nCopyPasteController = CopyPasteController_1 = __decorate([__param(1, IInstantiationService), __param(2, IBulkEditService), __param(3, IClipboardService), __param(4, ILanguageFeaturesService), __param(5, IQuickInputService), __param(6, IProgressService)], CopyPasteController);\nexport { CopyPasteController };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","CopyPasteController_1","addDisposableListener","getActiveDocument","coalesce","createCancelablePromise","DeferredPromise","raceCancellation","CancellationTokenSource","UriList","createStringDataTransferItem","matchesMimeType","HierarchicalKind","Disposable","DisposableStore","Mimes","platform","generateUuid","ClipboardEventUtils","toExternalVSDataTransfer","toVSDataTransfer","IBulkEditService","Range","DocumentPasteTriggerKind","ILanguageFeaturesService","DefaultTextPasteOrDropEditProvider","createCombinedWorkspaceEdit","sortEditsByYieldTo","EditorStateCancellationTokenSource","InlineProgressManager","MessageController","localize","IClipboardService","RawContextKey","IInstantiationService","IProgressService","IQuickInputService","PostEditWidgetManager","CancellationError","isCancellationError","changePasteTypeCommandId","pasteWidgetVisibleCtx","vscodeClipboardMime","CopyPasteController","_","_2","ID","get","editor","getContribution","constructor","instantiationService","_bulkEditService","_clipboardService","_languageFeaturesService","_quickInputService","_progressService","_editor","container","getContainerDomNode","_register","e","handleCopy","handlePaste","_pasteProgressManager","_postPasteWidgetManager","createInstance","id","label","changePasteType","tryShowSelector","pasteAs","preferred","focus","_pasteAsActionContext","execCommand","undefined","clearWidgets","clear","isPasteAsEnabled","getOption","enabled","finishedPaste","_this","_asyncToGenerator","_currentPasteOperation","hasTextFocus","clearInternalState","clipboardData","model","getModel","selections","getSelections","enableEmptySelectionClipboard","ranges","wasFromEmptySelection","isEmpty","startLineNumber","getLineLength","toCopy","_getViewModel","getPlainTextToCopy","isWindows","multicursorText","Array","isArray","defaultPastePayload","pasteOnNewLine","mode","providers","documentPasteEditProvider","ordered","filter","x","prepareDocumentPaste","setCopyMetadata","dataTransfer","providerCopyMimeTypes","flatMap","copyMimeTypes","handle","promise","_ref","token","results","Promise","all","map","_ref2","provider","err","console","error","_x2","apply","reverse","result","mime","value","replace","_x","_currentCopyOperation","dataTransferPromise","cancel","_this2","closeMessage","metadata","fetchCopyMetadata","delete","allPotentialMimeTypes","types","uriList","allProviders","preference","providedPasteEditKinds","providerMatchesPreference","pasteMimeTypes","some","type","showPasteAsNoEditMessage","preventDefault","stopImmediatePropagation","showPasteAsPick","doPasteInline","showMessage","providerId","getStartPosition","clipboardEvent","_this3","hasModel","editorStateCts","p","_ref3","pToken","disposables","cts","add","onCancellationRequested","mergeInDataFromCopy","isCancellationRequested","supportedProviders","isSupportedPasteProvider","applyDefaultPasteHandler","context","triggerKind","Automatic","editSession","getPasteEdits","edits","canShowWidget","showPasteSelector","applyEditAndShowIfNeeded","activeEditIndex","allEdits","edit","resolve","reject","resolveP","resolveDocumentPasteEdit","showP","resolved","showWhile","getEndPosition","race","additionalEdit","dispose","_x3","_ref5","then","_this4","_ref6","tokenSource","PasteAs","only","contains","kind","pickedEdit","at","selected","pick","title","description","placeHolder","combinedWorkspaceEdit","uri","_x4","withProgress","location","setData","JSON","stringify","rawMetadata","getData","parse","getTextData","isFromEmptySelection","_this5","toMergeDataTransfer","has","resources","readResources","append","create","_ref7","provideDocumentPasteEdits","_x5","flat","_this6","textDataTransfer","text","asString","payload","trigger","matches","providedKind"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar CopyPasteController_1;\nimport { addDisposableListener, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, DeferredPromise, raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { UriList, createStringDataTransferItem, matchesMimeType } from '../../../../base/common/dataTransfer.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../../base/common/mime.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { ClipboardEventUtils } from '../../../browser/controller/textAreaInput.js';\nimport { toExternalVSDataTransfer, toVSDataTransfer } from '../../../browser/dnd.js';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentPasteTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { DefaultTextPasteOrDropEditProvider } from './defaultProviders.js';\nimport { createCombinedWorkspaceEdit, sortEditsByYieldTo } from './edit.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport { localize } from '../../../../nls.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProgressService } from '../../../../platform/progress/common/progress.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { PostEditWidgetManager } from './postEditWidget.js';\nimport { CancellationError, isCancellationError } from '../../../../base/common/errors.js';\nexport const changePasteTypeCommandId = 'editor.changePasteType';\nexport const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localize('pasteWidgetVisible', \"Whether the paste widget is showing\"));\nconst vscodeClipboardMime = 'application/vnd.code.copyMetadata';\nlet CopyPasteController = class CopyPasteController extends Disposable {\n    static { CopyPasteController_1 = this; }\n    static { this.ID = 'editor.contrib.copyPasteActionController'; }\n    static get(editor) {\n        return editor.getContribution(CopyPasteController_1.ID);\n    }\n    constructor(editor, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {\n        super();\n        this._bulkEditService = _bulkEditService;\n        this._clipboardService = _clipboardService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._quickInputService = _quickInputService;\n        this._progressService = _progressService;\n        this._editor = editor;\n        const container = editor.getContainerDomNode();\n        this._register(addDisposableListener(container, 'copy', e => this.handleCopy(e)));\n        this._register(addDisposableListener(container, 'cut', e => this.handleCopy(e)));\n        this._register(addDisposableListener(container, 'paste', e => this.handlePaste(e), true));\n        this._pasteProgressManager = this._register(new InlineProgressManager('pasteIntoEditor', editor, instantiationService));\n        this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize('postPasteWidgetTitle', \"Show paste options...\") }));\n    }\n    changePasteType() {\n        this._postPasteWidgetManager.tryShowSelector();\n    }\n    pasteAs(preferred) {\n        this._editor.focus();\n        try {\n            this._pasteAsActionContext = { preferred };\n            getActiveDocument().execCommand('paste');\n        }\n        finally {\n            this._pasteAsActionContext = undefined;\n        }\n    }\n    clearWidgets() {\n        this._postPasteWidgetManager.clear();\n    }\n    isPasteAsEnabled() {\n        return this._editor.getOption(85 /* EditorOption.pasteAs */).enabled;\n    }\n    async finishedPaste() {\n        await this._currentPasteOperation;\n    }\n    handleCopy(e) {\n        if (!this._editor.hasTextFocus()) {\n            return;\n        }\n        // Explicitly clear the clipboard internal state.\n        // This is needed because on web, the browser clipboard is faked out using an in-memory store.\n        // This means the resources clipboard is not properly updated when copying from the editor.\n        this._clipboardService.clearInternalState?.();\n        if (!e.clipboardData || !this.isPasteAsEnabled()) {\n            return;\n        }\n        const model = this._editor.getModel();\n        const selections = this._editor.getSelections();\n        if (!model || !selections?.length) {\n            return;\n        }\n        const enableEmptySelectionClipboard = this._editor.getOption(37 /* EditorOption.emptySelectionClipboard */);\n        let ranges = selections;\n        const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();\n        if (wasFromEmptySelection) {\n            if (!enableEmptySelectionClipboard) {\n                return;\n            }\n            ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];\n        }\n        const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);\n        const multicursorText = Array.isArray(toCopy) ? toCopy : null;\n        const defaultPastePayload = {\n            multicursorText,\n            pasteOnNewLine: wasFromEmptySelection,\n            mode: null\n        };\n        const providers = this._languageFeaturesService.documentPasteEditProvider\n            .ordered(model)\n            .filter(x => !!x.prepareDocumentPaste);\n        if (!providers.length) {\n            this.setCopyMetadata(e.clipboardData, { defaultPastePayload });\n            return;\n        }\n        const dataTransfer = toVSDataTransfer(e.clipboardData);\n        const providerCopyMimeTypes = providers.flatMap(x => x.copyMimeTypes ?? []);\n        // Save off a handle pointing to data that VS Code maintains.\n        const handle = generateUuid();\n        this.setCopyMetadata(e.clipboardData, {\n            id: handle,\n            providerCopyMimeTypes,\n            defaultPastePayload\n        });\n        const promise = createCancelablePromise(async (token) => {\n            const results = coalesce(await Promise.all(providers.map(async (provider) => {\n                try {\n                    return await provider.prepareDocumentPaste(model, ranges, dataTransfer, token);\n                }\n                catch (err) {\n                    console.error(err);\n                    return undefined;\n                }\n            })));\n            // Values from higher priority providers should overwrite values from lower priority ones.\n            // Reverse the array to so that the calls to `replace` below will do this\n            results.reverse();\n            for (const result of results) {\n                for (const [mime, value] of result) {\n                    dataTransfer.replace(mime, value);\n                }\n            }\n            return dataTransfer;\n        });\n        CopyPasteController_1._currentCopyOperation?.dataTransferPromise.cancel();\n        CopyPasteController_1._currentCopyOperation = { handle: handle, dataTransferPromise: promise };\n    }\n    async handlePaste(e) {\n        if (!e.clipboardData || !this._editor.hasTextFocus()) {\n            return;\n        }\n        MessageController.get(this._editor)?.closeMessage();\n        this._currentPasteOperation?.cancel();\n        this._currentPasteOperation = undefined;\n        const model = this._editor.getModel();\n        const selections = this._editor.getSelections();\n        if (!selections?.length || !model) {\n            return;\n        }\n        if (this._editor.getOption(92 /* EditorOption.readOnly */) // Never enabled if editor is readonly.\n            || (!this.isPasteAsEnabled() && !this._pasteAsActionContext) // Or feature disabled (but still enable if paste was explicitly requested)\n        ) {\n            return;\n        }\n        const metadata = this.fetchCopyMetadata(e);\n        const dataTransfer = toExternalVSDataTransfer(e.clipboardData);\n        dataTransfer.delete(vscodeClipboardMime);\n        const allPotentialMimeTypes = [\n            ...e.clipboardData.types,\n            ...metadata?.providerCopyMimeTypes ?? [],\n            // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.\n            // However we can only check the system clipboard async. For this early check, just add it in.\n            // We filter providers again once we have the final dataTransfer we will use.\n            Mimes.uriList,\n        ];\n        const allProviders = this._languageFeaturesService.documentPasteEditProvider\n            .ordered(model)\n            .filter(provider => {\n            // Filter out providers that don't match the requested paste types\n            const preference = this._pasteAsActionContext?.preferred;\n            if (preference) {\n                if (provider.providedPasteEditKinds && !this.providerMatchesPreference(provider, preference)) {\n                    return false;\n                }\n            }\n            // And providers that don't handle any of mime types in the clipboard\n            return provider.pasteMimeTypes?.some(type => matchesMimeType(type, allPotentialMimeTypes));\n        });\n        if (!allProviders.length) {\n            if (this._pasteAsActionContext?.preferred) {\n                this.showPasteAsNoEditMessage(selections, this._pasteAsActionContext.preferred);\n            }\n            return;\n        }\n        // Prevent the editor's default paste handler from running.\n        // Note that after this point, we are fully responsible for handling paste.\n        // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        if (this._pasteAsActionContext) {\n            this.showPasteAsPick(this._pasteAsActionContext.preferred, allProviders, selections, dataTransfer, metadata);\n        }\n        else {\n            this.doPasteInline(allProviders, selections, dataTransfer, metadata, e);\n        }\n    }\n    showPasteAsNoEditMessage(selections, preference) {\n        MessageController.get(this._editor)?.showMessage(localize('pasteAsError', \"No paste edits for '{0}' found\", preference instanceof HierarchicalKind ? preference.value : preference.providerId), selections[0].getStartPosition());\n    }\n    doPasteInline(allProviders, selections, dataTransfer, metadata, clipboardEvent) {\n        const editor = this._editor;\n        if (!editor.hasModel()) {\n            return;\n        }\n        const editorStateCts = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined);\n        const p = createCancelablePromise(async (pToken) => {\n            const editor = this._editor;\n            if (!editor.hasModel()) {\n                return;\n            }\n            const model = editor.getModel();\n            const disposables = new DisposableStore();\n            const cts = disposables.add(new CancellationTokenSource(pToken));\n            disposables.add(editorStateCts.token.onCancellationRequested(() => cts.cancel()));\n            const token = cts.token;\n            try {\n                await this.mergeInDataFromCopy(dataTransfer, metadata, token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                const supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer));\n                if (!supportedProviders.length\n                    || (supportedProviders.length === 1 && supportedProviders[0] instanceof DefaultTextPasteOrDropEditProvider) // Only our default text provider is active\n                ) {\n                    return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n                }\n                const context = {\n                    triggerKind: DocumentPasteTriggerKind.Automatic,\n                };\n                const editSession = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, token);\n                disposables.add(editSession);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                // If the only edit returned is our default text edit, use the default paste handler\n                if (editSession.edits.length === 1 && editSession.edits[0].provider instanceof DefaultTextPasteOrDropEditProvider) {\n                    return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n                }\n                if (editSession.edits.length) {\n                    const canShowWidget = editor.getOption(85 /* EditorOption.pasteAs */).showPasteSelector === 'afterPaste';\n                    return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: 0, allEdits: editSession.edits }, canShowWidget, (edit, token) => {\n                        return new Promise((resolve, reject) => {\n                            (async () => {\n                                try {\n                                    const resolveP = edit.provider.resolveDocumentPasteEdit?.(edit, token);\n                                    const showP = new DeferredPromise();\n                                    const resolved = resolveP && await this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('resolveProcess', \"Resolving paste edit. Click to cancel\"), Promise.race([showP.p, resolveP]), {\n                                        cancel: () => {\n                                            showP.cancel();\n                                            return reject(new CancellationError());\n                                        }\n                                    }, 0);\n                                    if (resolved) {\n                                        edit.additionalEdit = resolved.additionalEdit;\n                                    }\n                                    return resolve(edit);\n                                }\n                                catch (err) {\n                                    return reject(err);\n                                }\n                            })();\n                        });\n                    }, token);\n                }\n                await this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n            }\n            finally {\n                disposables.dispose();\n                if (this._currentPasteOperation === p) {\n                    this._currentPasteOperation = undefined;\n                }\n            }\n        });\n        this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('pasteIntoEditorProgress', \"Running paste handlers. Click to cancel and do basic paste\"), p, {\n            cancel: async () => {\n                try {\n                    p.cancel();\n                    if (editorStateCts.token.isCancellationRequested) {\n                        return;\n                    }\n                    await this.applyDefaultPasteHandler(dataTransfer, metadata, editorStateCts.token, clipboardEvent);\n                }\n                finally {\n                    editorStateCts.dispose();\n                }\n            }\n        }).then(() => {\n            editorStateCts.dispose();\n        });\n        this._currentPasteOperation = p;\n    }\n    showPasteAsPick(preference, allProviders, selections, dataTransfer, metadata) {\n        const p = createCancelablePromise(async (token) => {\n            const editor = this._editor;\n            if (!editor.hasModel()) {\n                return;\n            }\n            const model = editor.getModel();\n            const disposables = new DisposableStore();\n            const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token));\n            try {\n                await this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);\n                if (tokenSource.token.isCancellationRequested) {\n                    return;\n                }\n                // Filter out any providers the don't match the full data transfer we will send them.\n                let supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer, preference));\n                if (preference) {\n                    // We are looking for a specific edit\n                    supportedProviders = supportedProviders.filter(provider => this.providerMatchesPreference(provider, preference));\n                }\n                const context = {\n                    triggerKind: DocumentPasteTriggerKind.PasteAs,\n                    only: preference && preference instanceof HierarchicalKind ? preference : undefined,\n                };\n                let editSession = disposables.add(await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, tokenSource.token));\n                if (tokenSource.token.isCancellationRequested) {\n                    return;\n                }\n                // Filter out any edits that don't match the requested kind\n                if (preference) {\n                    editSession = {\n                        edits: editSession.edits.filter(edit => {\n                            if (preference instanceof HierarchicalKind) {\n                                return preference.contains(edit.kind);\n                            }\n                            else {\n                                return preference.providerId === edit.provider.id;\n                            }\n                        }),\n                        dispose: editSession.dispose\n                    };\n                }\n                if (!editSession.edits.length) {\n                    if (context.only) {\n                        this.showPasteAsNoEditMessage(selections, context.only);\n                    }\n                    return;\n                }\n                let pickedEdit;\n                if (preference) {\n                    pickedEdit = editSession.edits.at(0);\n                }\n                else {\n                    const selected = await this._quickInputService.pick(editSession.edits.map((edit) => ({\n                        label: edit.title,\n                        description: edit.kind?.value,\n                        edit,\n                    })), {\n                        placeHolder: localize('pasteAsPickerPlaceholder', \"Select Paste Action\"),\n                    });\n                    pickedEdit = selected?.edit;\n                }\n                if (!pickedEdit) {\n                    return;\n                }\n                const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);\n                await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });\n            }\n            finally {\n                disposables.dispose();\n                if (this._currentPasteOperation === p) {\n                    this._currentPasteOperation = undefined;\n                }\n            }\n        });\n        this._progressService.withProgress({\n            location: 10 /* ProgressLocation.Window */,\n            title: localize('pasteAsProgress', \"Running paste handlers\"),\n        }, () => p);\n    }\n    setCopyMetadata(dataTransfer, metadata) {\n        dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));\n    }\n    fetchCopyMetadata(e) {\n        if (!e.clipboardData) {\n            return;\n        }\n        // Prefer using the clipboard data we saved off\n        const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);\n        if (rawMetadata) {\n            try {\n                return JSON.parse(rawMetadata);\n            }\n            catch {\n                return undefined;\n            }\n        }\n        // Otherwise try to extract the generic text editor metadata\n        const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n        if (metadata) {\n            return {\n                defaultPastePayload: {\n                    mode: metadata.mode,\n                    multicursorText: metadata.multicursorText ?? null,\n                    pasteOnNewLine: !!metadata.isFromEmptySelection,\n                },\n            };\n        }\n        return undefined;\n    }\n    async mergeInDataFromCopy(dataTransfer, metadata, token) {\n        if (metadata?.id && CopyPasteController_1._currentCopyOperation?.handle === metadata.id) {\n            const toMergeDataTransfer = await CopyPasteController_1._currentCopyOperation.dataTransferPromise;\n            if (token.isCancellationRequested) {\n                return;\n            }\n            for (const [key, value] of toMergeDataTransfer) {\n                dataTransfer.replace(key, value);\n            }\n        }\n        if (!dataTransfer.has(Mimes.uriList)) {\n            const resources = await this._clipboardService.readResources();\n            if (token.isCancellationRequested) {\n                return;\n            }\n            if (resources.length) {\n                dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));\n            }\n        }\n    }\n    async getPasteEdits(providers, dataTransfer, model, selections, context, token) {\n        const disposables = new DisposableStore();\n        const results = await raceCancellation(Promise.all(providers.map(async (provider) => {\n            try {\n                const edits = await provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, context, token);\n                if (edits) {\n                    disposables.add(edits);\n                }\n                return edits?.edits?.map(edit => ({ ...edit, provider }));\n            }\n            catch (err) {\n                if (!isCancellationError(err)) {\n                    console.error(err);\n                }\n                return undefined;\n            }\n        })), token);\n        const edits = coalesce(results ?? []).flat().filter(edit => {\n            return !context.only || context.only.contains(edit.kind);\n        });\n        return {\n            edits: sortEditsByYieldTo(edits),\n            dispose: () => disposables.dispose()\n        };\n    }\n    async applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent) {\n        const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get('text');\n        const text = (await textDataTransfer?.asString()) ?? '';\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const payload = {\n            clipboardEvent,\n            text,\n            pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,\n            multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,\n            mode: null,\n        };\n        this._editor.trigger('keyboard', \"paste\" /* Handler.Paste */, payload);\n    }\n    /**\n     * Filter out providers if they:\n     * - Don't handle any of the data transfer types we have\n     * - Don't match the preferred paste kind\n     */\n    isSupportedPasteProvider(provider, dataTransfer, preference) {\n        if (!provider.pasteMimeTypes?.some(type => dataTransfer.matches(type))) {\n            return false;\n        }\n        return !preference || this.providerMatchesPreference(provider, preference);\n    }\n    providerMatchesPreference(provider, preference) {\n        if (preference instanceof HierarchicalKind) {\n            if (!provider.providedPasteEditKinds) {\n                return true;\n            }\n            return provider.providedPasteEditKinds.some(providedKind => preference.contains(providedKind));\n        }\n        else {\n            return provider.id === preference.providerId;\n        }\n    }\n};\nCopyPasteController = CopyPasteController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IBulkEditService),\n    __param(3, IClipboardService),\n    __param(4, ILanguageFeaturesService),\n    __param(5, IQuickInputService),\n    __param(6, IProgressService)\n], CopyPasteController);\nexport { CopyPasteController };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}