{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\n/**\n * Custom mime type used for storing a list of uris in the clipboard.\n *\n * Requires support for custom web clipboards https://github.com/w3c/clipboard-apis/pull/175\n */\nconst vscodeResourcesMime = 'application/vnd.code.resources';\nlet BrowserClipboardService = /*#__PURE__*/(() => {\n  let BrowserClipboardService = class BrowserClipboardService extends Disposable {\n    static #_ = BrowserClipboardService_1 = this;\n    constructor(layoutService, logService) {\n      super();\n      this.layoutService = layoutService;\n      this.logService = logService;\n      this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n      this.findText = ''; // unsupported in web (only in-memory)\n      this.resources = []; // unsupported in web (only in-memory)\n      this.resourcesStateHash = undefined;\n      if (isSafari || isWebkitWebView) {\n        this.installWebKitWriteTextWorkaround();\n      }\n      // Keep track of copy operations to reset our set of\n      // copied resources: since we keep resources in memory\n      // and not in the clipboard, we have to invalidate\n      // that state when the user copies other data.\n      this._register(Event.runAndSubscribe(onDidRegisterWindow, ({\n        window,\n        disposables\n      }) => {\n        disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResourcesState()));\n      }, {\n        window: mainWindow,\n        disposables: this._store\n      }));\n    }\n    // In Safari, it has the following note:\n    //\n    // \"The request to write to the clipboard must be triggered during a user gesture.\n    // A call to clipboard.write or clipboard.writeText outside the scope of a user\n    // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n    // rejection of the promise returned by the API call.\"\n    // From: https://webkit.org/blog/10855/async-clipboard-api/\n    //\n    // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n    // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n    //\n    // This function sets up some handlers to work around that behavior.\n    installWebKitWriteTextWorkaround() {\n      var _this = this;\n      const handler = () => {\n        const currentWritePromise = new DeferredPromise();\n        // Cancel the previous promise since we just created a new one in response to this new event\n        if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n          this.webKitPendingClipboardWritePromise.cancel();\n        }\n        this.webKitPendingClipboardWritePromise = currentWritePromise;\n        // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n        // This allows us to pass in a Promise that will either be cancelled by another event or\n        // resolved with the contents of the first call to this.writeText.\n        // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n        getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n          'text/plain': currentWritePromise.p\n        })]).catch(/*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (err) {\n            if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n              _this.logService.error(err);\n            }\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      };\n      this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({\n        container,\n        disposables\n      }) => {\n        disposables.add(addDisposableListener(container, 'click', handler));\n        disposables.add(addDisposableListener(container, 'keydown', handler));\n      }, {\n        container: this.layoutService.mainContainer,\n        disposables: this._store\n      }));\n    }\n    writeText(text, type) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Clear resources given we are writing text\n        _this2.clearResourcesState();\n        // With type: only in-memory is supported\n        if (type) {\n          _this2.mapTextToType.set(type, text);\n          return;\n        }\n        if (_this2.webKitPendingClipboardWritePromise) {\n          // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n          // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n          // would throw an error because this call stack doesn't appear to originate from a user gesture.\n          return _this2.webKitPendingClipboardWritePromise.complete(text);\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n          return yield getActiveWindow().navigator.clipboard.writeText(text);\n        } catch (error) {\n          console.error(error);\n        }\n        // Fallback to textarea and execCommand solution\n        _this2.fallbackWriteText(text);\n      })();\n    }\n    fallbackWriteText(text) {\n      const activeDocument = getActiveDocument();\n      const activeElement = activeDocument.activeElement;\n      const textArea = activeDocument.body.appendChild($('textarea', {\n        'aria-hidden': true\n      }));\n      textArea.style.height = '1px';\n      textArea.style.width = '1px';\n      textArea.style.position = 'absolute';\n      textArea.value = text;\n      textArea.focus();\n      textArea.select();\n      activeDocument.execCommand('copy');\n      if (isHTMLElement(activeElement)) {\n        activeElement.focus();\n      }\n      textArea.remove();\n    }\n    readText(type) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        // With type: only in-memory is supported\n        if (type) {\n          return _this3.mapTextToType.get(type) || '';\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n          return yield getActiveWindow().navigator.clipboard.readText();\n        } catch (error) {\n          console.error(error);\n        }\n        return '';\n      })();\n    }\n    readFindText() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        return _this4.findText;\n      })();\n    }\n    writeFindText(text) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        _this5.findText = text;\n      })();\n    }\n    static #_2 = this.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000;\n    readResources() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n          const items = yield getActiveWindow().navigator.clipboard.read();\n          for (const item of items) {\n            if (item.types.includes(`web ${vscodeResourcesMime}`)) {\n              const blob = yield item.getType(`web ${vscodeResourcesMime}`);\n              const resources = JSON.parse(yield blob.text()).map(x => URI.from(x));\n              return resources;\n            }\n          }\n        } catch (error) {\n          // Noop\n        }\n        const resourcesStateHash = yield _this6.computeResourcesStateHash();\n        if (_this6.resourcesStateHash !== resourcesStateHash) {\n          _this6.clearResourcesState(); // state mismatch, resources no longer valid\n        }\n        return _this6.resources;\n      })();\n    }\n    computeResourcesStateHash() {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        if (_this7.resources.length === 0) {\n          return undefined; // no resources, no hash needed\n        }\n        // Resources clipboard is managed in-memory only and thus\n        // fails to invalidate when clipboard data is changing.\n        // As such, we compute the hash of the current clipboard\n        // and use that to later validate the resources clipboard.\n        const clipboardText = yield _this7.readText();\n        return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n      })();\n    }\n    clearInternalState() {\n      this.clearResourcesState();\n    }\n    clearResourcesState() {\n      this.resources = [];\n      this.resourcesStateHash = undefined;\n    }\n  };\n  return BrowserClipboardService;\n})();\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([__param(0, ILayoutService), __param(1, ILogService)], BrowserClipboardService);\nexport { BrowserClipboardService };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","BrowserClipboardService_1","isSafari","isWebkitWebView","$","addDisposableListener","getActiveDocument","getActiveWindow","isHTMLElement","onDidRegisterWindow","mainWindow","DeferredPromise","Event","hash","Disposable","URI","ILayoutService","ILogService","vscodeResourcesMime","BrowserClipboardService","_","constructor","layoutService","logService","mapTextToType","Map","findText","resources","resourcesStateHash","undefined","installWebKitWriteTextWorkaround","_register","runAndSubscribe","window","disposables","add","document","clearResourcesState","_store","_this","handler","currentWritePromise","webKitPendingClipboardWritePromise","isSettled","cancel","navigator","clipboard","write","ClipboardItem","p","catch","_ref","_asyncToGenerator","err","Error","name","isRejected","error","_x","apply","onDidAddContainer","container","mainContainer","writeText","text","type","_this2","set","complete","console","fallbackWriteText","activeDocument","activeElement","textArea","body","appendChild","style","height","width","position","value","focus","select","execCommand","remove","readText","_this3","get","readFindText","_this4","writeFindText","_this5","_2","MAX_RESOURCE_STATE_SOURCE_LENGTH","readResources","_this6","items","read","item","types","includes","blob","getType","JSON","parse","map","x","from","computeResourcesStateHash","_this7","clipboardText","substring","clearInternalState"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\n/**\n * Custom mime type used for storing a list of uris in the clipboard.\n *\n * Requires support for custom web clipboards https://github.com/w3c/clipboard-apis/pull/175\n */\nconst vscodeResourcesMime = 'application/vnd.code.resources';\nlet BrowserClipboardService = class BrowserClipboardService extends Disposable {\n    static { BrowserClipboardService_1 = this; }\n    constructor(layoutService, logService) {\n        super();\n        this.layoutService = layoutService;\n        this.logService = logService;\n        this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n        this.findText = ''; // unsupported in web (only in-memory)\n        this.resources = []; // unsupported in web (only in-memory)\n        this.resourcesStateHash = undefined;\n        if (isSafari || isWebkitWebView) {\n            this.installWebKitWriteTextWorkaround();\n        }\n        // Keep track of copy operations to reset our set of\n        // copied resources: since we keep resources in memory\n        // and not in the clipboard, we have to invalidate\n        // that state when the user copies other data.\n        this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {\n            disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResourcesState()));\n        }, { window: mainWindow, disposables: this._store }));\n    }\n    // In Safari, it has the following note:\n    //\n    // \"The request to write to the clipboard must be triggered during a user gesture.\n    // A call to clipboard.write or clipboard.writeText outside the scope of a user\n    // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n    // rejection of the promise returned by the API call.\"\n    // From: https://webkit.org/blog/10855/async-clipboard-api/\n    //\n    // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n    // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n    //\n    // This function sets up some handlers to work around that behavior.\n    installWebKitWriteTextWorkaround() {\n        const handler = () => {\n            const currentWritePromise = new DeferredPromise();\n            // Cancel the previous promise since we just created a new one in response to this new event\n            if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n                this.webKitPendingClipboardWritePromise.cancel();\n            }\n            this.webKitPendingClipboardWritePromise = currentWritePromise;\n            // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n            // This allows us to pass in a Promise that will either be cancelled by another event or\n            // resolved with the contents of the first call to this.writeText.\n            // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n            getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n                    'text/plain': currentWritePromise.p,\n                })]).catch(async (err) => {\n                if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n                    this.logService.error(err);\n                }\n            });\n        };\n        this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n            disposables.add(addDisposableListener(container, 'click', handler));\n            disposables.add(addDisposableListener(container, 'keydown', handler));\n        }, { container: this.layoutService.mainContainer, disposables: this._store }));\n    }\n    async writeText(text, type) {\n        // Clear resources given we are writing text\n        this.clearResourcesState();\n        // With type: only in-memory is supported\n        if (type) {\n            this.mapTextToType.set(type, text);\n            return;\n        }\n        if (this.webKitPendingClipboardWritePromise) {\n            // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n            // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n            // would throw an error because this call stack doesn't appear to originate from a user gesture.\n            return this.webKitPendingClipboardWritePromise.complete(text);\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.writeText(text);\n        }\n        catch (error) {\n            console.error(error);\n        }\n        // Fallback to textarea and execCommand solution\n        this.fallbackWriteText(text);\n    }\n    fallbackWriteText(text) {\n        const activeDocument = getActiveDocument();\n        const activeElement = activeDocument.activeElement;\n        const textArea = activeDocument.body.appendChild($('textarea', { 'aria-hidden': true }));\n        textArea.style.height = '1px';\n        textArea.style.width = '1px';\n        textArea.style.position = 'absolute';\n        textArea.value = text;\n        textArea.focus();\n        textArea.select();\n        activeDocument.execCommand('copy');\n        if (isHTMLElement(activeElement)) {\n            activeElement.focus();\n        }\n        textArea.remove();\n    }\n    async readText(type) {\n        // With type: only in-memory is supported\n        if (type) {\n            return this.mapTextToType.get(type) || '';\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.readText();\n        }\n        catch (error) {\n            console.error(error);\n        }\n        return '';\n    }\n    async readFindText() {\n        return this.findText;\n    }\n    async writeFindText(text) {\n        this.findText = text;\n    }\n    static { this.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000; }\n    async readResources() {\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            const items = await getActiveWindow().navigator.clipboard.read();\n            for (const item of items) {\n                if (item.types.includes(`web ${vscodeResourcesMime}`)) {\n                    const blob = await item.getType(`web ${vscodeResourcesMime}`);\n                    const resources = JSON.parse(await blob.text()).map(x => URI.from(x));\n                    return resources;\n                }\n            }\n        }\n        catch (error) {\n            // Noop\n        }\n        const resourcesStateHash = await this.computeResourcesStateHash();\n        if (this.resourcesStateHash !== resourcesStateHash) {\n            this.clearResourcesState(); // state mismatch, resources no longer valid\n        }\n        return this.resources;\n    }\n    async computeResourcesStateHash() {\n        if (this.resources.length === 0) {\n            return undefined; // no resources, no hash needed\n        }\n        // Resources clipboard is managed in-memory only and thus\n        // fails to invalidate when clipboard data is changing.\n        // As such, we compute the hash of the current clipboard\n        // and use that to later validate the resources clipboard.\n        const clipboardText = await this.readText();\n        return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n    }\n    clearInternalState() {\n        this.clearResourcesState();\n    }\n    clearResourcesState() {\n        this.resources = [];\n        this.resourcesStateHash = undefined;\n    }\n};\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ILogService)\n], BrowserClipboardService);\nexport { BrowserClipboardService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}