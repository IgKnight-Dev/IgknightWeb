{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens, error) {\n    this.provider = provider;\n    this.tokens = tokens;\n    this.error = error;\n  }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n  return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n  const groups = registry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentSemanticTokens(_x, _x2, _x3, _x4, _x5) {\n  return _getDocumentSemanticTokens.apply(this, arguments);\n}\nfunction _getDocumentSemanticTokens() {\n  _getDocumentSemanticTokens = _asyncToGenerator(function* (registry, model, lastProvider, lastResultId, token) {\n    const providers = getDocumentSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(/*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (provider) {\n        let result;\n        let error = null;\n        try {\n          result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n        } catch (err) {\n          error = err;\n          result = null;\n        }\n        if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n          result = null;\n        }\n        return new DocumentSemanticTokensResult(provider, result, error);\n      });\n      return function (_x12) {\n        return _ref5.apply(this, arguments);\n      };\n    }()));\n    // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n    for (const result of results) {\n      if (result.error) {\n        throw result.error;\n      }\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n  return _getDocumentSemanticTokens.apply(this, arguments);\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n  const result = registry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n  return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n  const groups = providers.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentRangeSemanticTokens(_x6, _x7, _x8, _x9) {\n  return _getDocumentRangeSemanticTokens.apply(this, arguments);\n}\nfunction _getDocumentRangeSemanticTokens() {\n  _getDocumentRangeSemanticTokens = _asyncToGenerator(function* (registry, model, range, token) {\n    const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(/*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator(function* (provider) {\n        let result;\n        try {\n          result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n        } catch (err) {\n          onUnexpectedExternalError(err);\n          result = null;\n        }\n        if (!result || !isSemanticTokens(result)) {\n          result = null;\n        }\n        return new DocumentRangeSemanticTokensResult(provider, result);\n      });\n      return function (_x13) {\n        return _ref6.apply(this, arguments);\n      };\n    }()));\n    // Try to return the first result with actual tokens\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n  return _getDocumentRangeSemanticTokens.apply(this, arguments);\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (accessor, ...args) {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n  });\n  return function (_x0) {\n    return _ref.apply(this, arguments);\n  };\n}());\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (accessor, ...args) {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n      // there is no provider => fall back to a document range semantic tokens provider\n      return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n      return undefined;\n    }\n    const {\n      provider,\n      tokens\n    } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n      return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: tokens.data\n    });\n    if (tokens.resultId) {\n      provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n  });\n  return function (_x1) {\n    return _ref2.apply(this, arguments);\n  };\n}());\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (accessor, ...args) {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentRangeSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n      // no providers\n      return undefined;\n    }\n    if (providers.length === 1) {\n      // straight forward case, just a single provider\n      return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n      // if no range is provided, we cannot support multiple providers\n      // as we cannot fall back to the one which would give results\n      // => return the first legend for backwards compatibility and print a warning\n      console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n      return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n      return undefined;\n    }\n    return result.provider.getLegend();\n  });\n  return function (_x10) {\n    return _ref3.apply(this, arguments);\n  };\n}());\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (accessor, ...args) {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n      return undefined;\n    }\n    const {\n      documentRangeSemanticTokensProvider\n    } = accessor.get(ILanguageFeaturesService);\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n      // there is no provider or it didn't return tokens\n      return undefined;\n    }\n    return encodeSemanticTokensDto({\n      id: 0,\n      type: 'full',\n      data: result.tokens.data\n    });\n  });\n  return function (_x11) {\n    return _ref4.apply(this, arguments);\n  };\n}());","map":{"version":3,"names":["CancellationToken","onUnexpectedExternalError","URI","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","ILanguageFeaturesService","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","error","hasDocumentSemanticTokensProvider","registry","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","_x","_x2","_x3","_x4","_x5","_getDocumentSemanticTokens","apply","arguments","_asyncToGenerator","lastProvider","lastResultId","token","providers","results","Promise","all","map","_ref5","result","provideDocumentSemanticTokens","err","_x12","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","_x6","_x7","_x8","_x9","_getDocumentRangeSemanticTokens","range","_ref6","provideDocumentRangeSemanticTokens","_x13","registerCommand","_ref","accessor","args","uri","get","getModel","undefined","documentSemanticTokensProvider","executeCommand","getLegend","_x0","_ref2","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","_x1","_ref3","documentRangeSemanticTokensProvider","isIRange","console","warn","lift","_x10","_ref4","_x11"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens, error) {\n        this.provider = provider;\n        this.tokens = tokens;\n        this.error = error;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n    return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n    const groups = registry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport async function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n    const providers = getDocumentSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = await Promise.all(providers.map(async (provider) => {\n        let result;\n        let error = null;\n        try {\n            result = await provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n        }\n        catch (err) {\n            error = err;\n            result = null;\n        }\n        if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n            result = null;\n        }\n        return new DocumentSemanticTokensResult(provider, result, error);\n    }));\n    // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n    for (const result of results) {\n        if (result.error) {\n            throw result.error;\n        }\n        if (result.tokens) {\n            return result;\n        }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n        return results[0];\n    }\n    return null;\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n    const result = registry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n    return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n    const groups = providers.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport async function getDocumentRangeSemanticTokens(registry, model, range, token) {\n    const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = await Promise.all(providers.map(async (provider) => {\n        let result;\n        try {\n            result = await provider.provideDocumentRangeSemanticTokens(model, range, token);\n        }\n        catch (err) {\n            onUnexpectedExternalError(err);\n            result = null;\n        }\n        if (!result || !isSemanticTokens(result)) {\n            result = null;\n        }\n        return new DocumentRangeSemanticTokensResult(provider, result);\n    }));\n    // Try to return the first result with actual tokens\n    for (const result of results) {\n        if (result.tokens) {\n            return result;\n        }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n        return results[0];\n    }\n    return null;\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', async (accessor, ...args) => {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', async (accessor, ...args) => {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', async (accessor, ...args) => {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n});\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', async (accessor, ...args) => {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n});\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,yCAAyC;AAC3E,SAASC,yBAAyB,QAAQ,mCAAmC;AAC7E,SAASC,GAAG,QAAQ,gCAAgC;AACpD,SAASC,aAAa,QAAQ,mCAAmC;AACjE,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,kDAAkD;AACpG,SAASC,UAAU,QAAQ,kCAAkC;AAC7D,SAASC,uBAAuB,QAAQ,+CAA+C;AACvF,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,wBAAwB,QAAQ,8CAA8C;AACvF,OAAO,SAASC,gBAAgBA,CAACC,CAAC,EAAE;EAChC,OAAOA,CAAC,IAAI,CAAC,CAAEA,CAAC,CAACC,IAAK;AAC1B;AACA,OAAO,SAASC,qBAAqBA,CAACF,CAAC,EAAE;EACrC,OAAOA,CAAC,IAAIG,KAAK,CAACC,OAAO,CAACJ,CAAC,CAACK,KAAK,CAAC;AACtC;AACA,OAAO,MAAMC,4BAA4B,CAAC;EACtCC,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,KAAK,EAAE;IACjC,IAAI,CAACF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACtB;AACJ;AACA,OAAO,SAASC,iCAAiCA,CAACC,QAAQ,EAAEC,KAAK,EAAE;EAC/D,OAAOD,QAAQ,CAACE,GAAG,CAACD,KAAK,CAAC;AAC9B;AACA,SAASE,kCAAkCA,CAACH,QAAQ,EAAEC,KAAK,EAAE;EACzD,MAAMG,MAAM,GAAGJ,QAAQ,CAACK,aAAa,CAACJ,KAAK,CAAC;EAC5C,OAAQG,MAAM,CAACE,MAAM,GAAG,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE;AAC9C;AACA,gBAAsBG,yBAAyBA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAiC9C,SAAAF,2BAAA;EAAAA,0BAAA,GAAAG,iBAAA,CAjCM,WAAyChB,QAAQ,EAAEC,KAAK,EAAEgB,YAAY,EAAEC,YAAY,EAAEC,KAAK,EAAE;IAChG,MAAMC,SAAS,GAAGjB,kCAAkC,CAACH,QAAQ,EAAEC,KAAK,CAAC;IACrE;IACA,MAAMoB,OAAO,SAASC,OAAO,CAACC,GAAG,CAACH,SAAS,CAACI,GAAG;MAAA,IAAAC,KAAA,GAAAT,iBAAA,CAAC,WAAOpB,QAAQ,EAAK;QAChE,IAAI8B,MAAM;QACV,IAAI5B,KAAK,GAAG,IAAI;QAChB,IAAI;UACA4B,MAAM,SAAS9B,QAAQ,CAAC+B,6BAA6B,CAAC1B,KAAK,EAAGL,QAAQ,KAAKqB,YAAY,GAAGC,YAAY,GAAG,IAAI,EAAGC,KAAK,CAAC;QAC1H,CAAC,CACD,OAAOS,GAAG,EAAE;UACR9B,KAAK,GAAG8B,GAAG;UACXF,MAAM,GAAG,IAAI;QACjB;QACA,IAAI,CAACA,MAAM,IAAK,CAACvC,gBAAgB,CAACuC,MAAM,CAAC,IAAI,CAACpC,qBAAqB,CAACoC,MAAM,CAAE,EAAE;UAC1EA,MAAM,GAAG,IAAI;QACjB;QACA,OAAO,IAAIhC,4BAA4B,CAACE,QAAQ,EAAE8B,MAAM,EAAE5B,KAAK,CAAC;MACpE,CAAC;MAAA,iBAAA+B,IAAA;QAAA,OAAAJ,KAAA,CAAAX,KAAA,OAAAC,SAAA;MAAA;IAAA,IAAC,CAAC;IACH;IACA;IACA,KAAK,MAAMW,MAAM,IAAIL,OAAO,EAAE;MAC1B,IAAIK,MAAM,CAAC5B,KAAK,EAAE;QACd,MAAM4B,MAAM,CAAC5B,KAAK;MACtB;MACA,IAAI4B,MAAM,CAAC7B,MAAM,EAAE;QACf,OAAO6B,MAAM;MACjB;IACJ;IACA;IACA,IAAIL,OAAO,CAACf,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOe,OAAO,CAAC,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACf,CAAC;EAAA,OAAAR,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AACD,SAASe,8CAA8CA,CAAC9B,QAAQ,EAAEC,KAAK,EAAE;EACrE,MAAMyB,MAAM,GAAG1B,QAAQ,CAACK,aAAa,CAACJ,KAAK,CAAC;EAC5C,OAAQyB,MAAM,CAACpB,MAAM,GAAG,CAAC,GAAGoB,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI;AAChD;AACA,MAAMK,iCAAiC,CAAC;EACpCpC,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IAC1B,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACxB;AACJ;AACA,OAAO,SAASmC,sCAAsCA,CAACZ,SAAS,EAAEnB,KAAK,EAAE;EACrE,OAAOmB,SAAS,CAAClB,GAAG,CAACD,KAAK,CAAC;AAC/B;AACA,SAASgC,uCAAuCA,CAACb,SAAS,EAAEnB,KAAK,EAAE;EAC/D,MAAMG,MAAM,GAAGgB,SAAS,CAACf,aAAa,CAACJ,KAAK,CAAC;EAC7C,OAAQG,MAAM,CAACE,MAAM,GAAG,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE;AAC9C;AACA,gBAAsB8B,8BAA8BA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,+BAAA,CAAAzB,KAAA,OAAAC,SAAA;AAAA;AA4BnD,SAAAwB,gCAAA;EAAAA,+BAAA,GAAAvB,iBAAA,CA5BM,WAA8ChB,QAAQ,EAAEC,KAAK,EAAEuC,KAAK,EAAErB,KAAK,EAAE;IAChF,MAAMC,SAAS,GAAGa,uCAAuC,CAACjC,QAAQ,EAAEC,KAAK,CAAC;IAC1E;IACA,MAAMoB,OAAO,SAASC,OAAO,CAACC,GAAG,CAACH,SAAS,CAACI,GAAG;MAAA,IAAAiB,KAAA,GAAAzB,iBAAA,CAAC,WAAOpB,QAAQ,EAAK;QAChE,IAAI8B,MAAM;QACV,IAAI;UACAA,MAAM,SAAS9B,QAAQ,CAAC8C,kCAAkC,CAACzC,KAAK,EAAEuC,KAAK,EAAErB,KAAK,CAAC;QACnF,CAAC,CACD,OAAOS,GAAG,EAAE;UACRlD,yBAAyB,CAACkD,GAAG,CAAC;UAC9BF,MAAM,GAAG,IAAI;QACjB;QACA,IAAI,CAACA,MAAM,IAAI,CAACvC,gBAAgB,CAACuC,MAAM,CAAC,EAAE;UACtCA,MAAM,GAAG,IAAI;QACjB;QACA,OAAO,IAAIK,iCAAiC,CAACnC,QAAQ,EAAE8B,MAAM,CAAC;MAClE,CAAC;MAAA,iBAAAiB,IAAA;QAAA,OAAAF,KAAA,CAAA3B,KAAA,OAAAC,SAAA;MAAA;IAAA,IAAC,CAAC;IACH;IACA,KAAK,MAAMW,MAAM,IAAIL,OAAO,EAAE;MAC1B,IAAIK,MAAM,CAAC7B,MAAM,EAAE;QACf,OAAO6B,MAAM;MACjB;IACJ;IACA;IACA,IAAIL,OAAO,CAACf,MAAM,GAAG,CAAC,EAAE;MACpB,OAAOe,OAAO,CAAC,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACf,CAAC;EAAA,OAAAkB,+BAAA,CAAAzB,KAAA,OAAAC,SAAA;AAAA;AACDlC,gBAAgB,CAAC+D,eAAe,CAAC,sCAAsC;EAAA,IAAAC,IAAA,GAAA7B,iBAAA,CAAE,WAAO8B,QAAQ,EAAE,GAAGC,IAAI,EAAK;IAClG,MAAM,CAACC,GAAG,CAAC,GAAGD,IAAI;IAClBhE,UAAU,CAACiE,GAAG,YAAYrE,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAG6C,QAAQ,CAACG,GAAG,CAACrE,aAAa,CAAC,CAACsE,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC/C,KAAK,EAAE;MACR,OAAOkD,SAAS;IACpB;IACA,MAAM;MAAEC;IAA+B,CAAC,GAAGN,QAAQ,CAACG,GAAG,CAAC/D,wBAAwB,CAAC;IACjF,MAAMkC,SAAS,GAAGU,8CAA8C,CAACsB,8BAA8B,EAAEnD,KAAK,CAAC;IACvG,IAAI,CAACmB,SAAS,EAAE;MACZ;MACA,OAAO0B,QAAQ,CAACG,GAAG,CAACnE,eAAe,CAAC,CAACuE,cAAc,CAAC,2CAA2C,EAAEL,GAAG,CAAC;IACzG;IACA,OAAO5B,SAAS,CAAC,CAAC,CAAC,CAACkC,SAAS,CAAC,CAAC;EACnC,CAAC;EAAA,iBAAAC,GAAA;IAAA,OAAAV,IAAA,CAAA/B,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC;AACFlC,gBAAgB,CAAC+D,eAAe,CAAC,gCAAgC;EAAA,IAAAY,KAAA,GAAAxC,iBAAA,CAAE,WAAO8B,QAAQ,EAAE,GAAGC,IAAI,EAAK;IAC5F,MAAM,CAACC,GAAG,CAAC,GAAGD,IAAI;IAClBhE,UAAU,CAACiE,GAAG,YAAYrE,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAG6C,QAAQ,CAACG,GAAG,CAACrE,aAAa,CAAC,CAACsE,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC/C,KAAK,EAAE;MACR,OAAOkD,SAAS;IACpB;IACA,MAAM;MAAEC;IAA+B,CAAC,GAAGN,QAAQ,CAACG,GAAG,CAAC/D,wBAAwB,CAAC;IACjF,IAAI,CAACa,iCAAiC,CAACqD,8BAA8B,EAAEnD,KAAK,CAAC,EAAE;MAC3E;MACA,OAAO6C,QAAQ,CAACG,GAAG,CAACnE,eAAe,CAAC,CAACuE,cAAc,CAAC,qCAAqC,EAAEL,GAAG,EAAE/C,KAAK,CAACwD,iBAAiB,CAAC,CAAC,CAAC;IAC9H;IACA,MAAMC,CAAC,SAASnD,yBAAyB,CAAC6C,8BAA8B,EAAEnD,KAAK,EAAE,IAAI,EAAE,IAAI,EAAExB,iBAAiB,CAACkF,IAAI,CAAC;IACpH,IAAI,CAACD,CAAC,EAAE;MACJ,OAAOP,SAAS;IACpB;IACA,MAAM;MAAEvD,QAAQ;MAAEC;IAAO,CAAC,GAAG6D,CAAC;IAC9B,IAAI,CAAC7D,MAAM,IAAI,CAACV,gBAAgB,CAACU,MAAM,CAAC,EAAE;MACtC,OAAOsD,SAAS;IACpB;IACA,MAAMS,IAAI,GAAG5E,uBAAuB,CAAC;MACjC6E,EAAE,EAAE,CAAC;MACLC,IAAI,EAAE,MAAM;MACZzE,IAAI,EAAEQ,MAAM,CAACR;IACjB,CAAC,CAAC;IACF,IAAIQ,MAAM,CAACkE,QAAQ,EAAE;MACjBnE,QAAQ,CAACoE,6BAA6B,CAACnE,MAAM,CAACkE,QAAQ,CAAC;IAC3D;IACA,OAAOH,IAAI;EACf,CAAC;EAAA,iBAAAK,GAAA;IAAA,OAAAT,KAAA,CAAA1C,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC;AACFlC,gBAAgB,CAAC+D,eAAe,CAAC,2CAA2C;EAAA,IAAAsB,KAAA,GAAAlD,iBAAA,CAAE,WAAO8B,QAAQ,EAAE,GAAGC,IAAI,EAAK;IACvG,MAAM,CAACC,GAAG,EAAER,KAAK,CAAC,GAAGO,IAAI;IACzBhE,UAAU,CAACiE,GAAG,YAAYrE,GAAG,CAAC;IAC9B,MAAMsB,KAAK,GAAG6C,QAAQ,CAACG,GAAG,CAACrE,aAAa,CAAC,CAACsE,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC/C,KAAK,EAAE;MACR,OAAOkD,SAAS;IACpB;IACA,MAAM;MAAEgB;IAAoC,CAAC,GAAGrB,QAAQ,CAACG,GAAG,CAAC/D,wBAAwB,CAAC;IACtF,MAAMkC,SAAS,GAAGa,uCAAuC,CAACkC,mCAAmC,EAAElE,KAAK,CAAC;IACrG,IAAImB,SAAS,CAACd,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAO6C,SAAS;IACpB;IACA,IAAI/B,SAAS,CAACd,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAOc,SAAS,CAAC,CAAC,CAAC,CAACkC,SAAS,CAAC,CAAC;IACnC;IACA,IAAI,CAACd,KAAK,IAAI,CAACvD,KAAK,CAACmF,QAAQ,CAAC5B,KAAK,CAAC,EAAE;MAClC;MACA;MACA;MACA6B,OAAO,CAACC,IAAI,CAAC,4IAA4I,CAAC;MAC1J,OAAOlD,SAAS,CAAC,CAAC,CAAC,CAACkC,SAAS,CAAC,CAAC;IACnC;IACA,MAAM5B,MAAM,SAASQ,8BAA8B,CAACiC,mCAAmC,EAAElE,KAAK,EAAEhB,KAAK,CAACsF,IAAI,CAAC/B,KAAK,CAAC,EAAE/D,iBAAiB,CAACkF,IAAI,CAAC;IAC1I,IAAI,CAACjC,MAAM,EAAE;MACT,OAAOyB,SAAS;IACpB;IACA,OAAOzB,MAAM,CAAC9B,QAAQ,CAAC0D,SAAS,CAAC,CAAC;EACtC,CAAC;EAAA,iBAAAkB,IAAA;IAAA,OAAAN,KAAA,CAAApD,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC;AACFlC,gBAAgB,CAAC+D,eAAe,CAAC,qCAAqC;EAAA,IAAA6B,KAAA,GAAAzD,iBAAA,CAAE,WAAO8B,QAAQ,EAAE,GAAGC,IAAI,EAAK;IACjG,MAAM,CAACC,GAAG,EAAER,KAAK,CAAC,GAAGO,IAAI;IACzBhE,UAAU,CAACiE,GAAG,YAAYrE,GAAG,CAAC;IAC9BI,UAAU,CAACE,KAAK,CAACmF,QAAQ,CAAC5B,KAAK,CAAC,CAAC;IACjC,MAAMvC,KAAK,GAAG6C,QAAQ,CAACG,GAAG,CAACrE,aAAa,CAAC,CAACsE,QAAQ,CAACF,GAAG,CAAC;IACvD,IAAI,CAAC/C,KAAK,EAAE;MACR,OAAOkD,SAAS;IACpB;IACA,MAAM;MAAEgB;IAAoC,CAAC,GAAGrB,QAAQ,CAACG,GAAG,CAAC/D,wBAAwB,CAAC;IACtF,MAAMwC,MAAM,SAASQ,8BAA8B,CAACiC,mCAAmC,EAAElE,KAAK,EAAEhB,KAAK,CAACsF,IAAI,CAAC/B,KAAK,CAAC,EAAE/D,iBAAiB,CAACkF,IAAI,CAAC;IAC1I,IAAI,CAACjC,MAAM,IAAI,CAACA,MAAM,CAAC7B,MAAM,EAAE;MAC3B;MACA,OAAOsD,SAAS;IACpB;IACA,OAAOnE,uBAAuB,CAAC;MAC3B6E,EAAE,EAAE,CAAC;MACLC,IAAI,EAAE,MAAM;MACZzE,IAAI,EAAEqC,MAAM,CAAC7B,MAAM,CAACR;IACxB,CAAC,CAAC;EACN,CAAC;EAAA,iBAAAqF,IAAA;IAAA,OAAAD,KAAA,CAAA3D,KAAA,OAAAC,SAAA;EAAA;AAAA,IAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}