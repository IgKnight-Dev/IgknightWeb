{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport let LineTokens = /*#__PURE__*/(() => {\n  class LineTokens {\n    static #_ = this.defaultTokenMetadata = (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | 1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | 2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */) >>> 0;\n    static createEmpty(lineContent, decoder) {\n      const defaultMetadata = LineTokens.defaultTokenMetadata;\n      const tokens = new Uint32Array(2);\n      tokens[0] = lineContent.length;\n      tokens[1] = defaultMetadata;\n      return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n      let offset = 0;\n      let fullText = '';\n      const tokens = new Array();\n      for (const {\n        text,\n        metadata\n      } of data) {\n        tokens.push(offset + text.length, metadata);\n        offset += text.length;\n        fullText += text;\n      }\n      return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n      this._lineTokensBrand = undefined;\n      this._tokens = tokens;\n      this._tokensCount = this._tokens.length >>> 1;\n      this._text = text;\n      this.languageIdCodec = decoder;\n    }\n    equals(other) {\n      if (other instanceof LineTokens) {\n        return this.slicedEquals(other, 0, this._tokensCount);\n      }\n      return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n      if (this._text !== other._text) {\n        return false;\n      }\n      if (this._tokensCount !== other._tokensCount) {\n        return false;\n      }\n      const from = sliceFromTokenIndex << 1;\n      const to = from + (sliceTokenCount << 1);\n      for (let i = from; i < to; i++) {\n        if (this._tokens[i] !== other._tokens[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    getLineContent() {\n      return this._text;\n    }\n    getCount() {\n      return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n      if (tokenIndex > 0) {\n        return this._tokens[tokenIndex - 1 << 1];\n      }\n      return 0;\n    }\n    getMetadata(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return metadata;\n    }\n    getLanguageId(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      const languageId = TokenMetadata.getLanguageId(metadata);\n      return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n      const metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n      return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n      return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n      return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n      return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n      const tokenCount = tokens.length >>> 1;\n      const lastTokenIndex = tokenCount - 1;\n      for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n        tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n      }\n      tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n      if (tokens.length <= 2) {\n        return 0;\n      }\n      let low = 0;\n      let high = (tokens.length >>> 1) - 1;\n      while (low < high) {\n        const mid = low + Math.floor((high - low) / 2);\n        const endOffset = tokens[mid << 1];\n        if (endOffset === desiredIndex) {\n          return mid + 1;\n        } else if (endOffset < desiredIndex) {\n          low = mid + 1;\n        } else if (endOffset > desiredIndex) {\n          high = mid;\n        }\n      }\n      return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n      if (insertTokens.length === 0) {\n        return this;\n      }\n      let nextOriginalTokenIdx = 0;\n      let nextInsertTokenIdx = 0;\n      let text = '';\n      const newTokens = new Array();\n      let originalEndOffset = 0;\n      while (true) {\n        const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n        const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n        if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n          // original token ends before next insert token\n          text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n          const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n          newTokens.push(text.length, metadata);\n          nextOriginalTokenIdx++;\n          originalEndOffset = nextOriginalTokenEndOffset;\n        } else if (nextInsertToken) {\n          if (nextInsertToken.offset > originalEndOffset) {\n            // insert token is in the middle of the next token.\n            text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n            const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n            newTokens.push(text.length, metadata);\n            originalEndOffset = nextInsertToken.offset;\n          }\n          text += nextInsertToken.text;\n          newTokens.push(text.length, nextInsertToken.tokenMetadata);\n          nextInsertTokenIdx++;\n        } else {\n          break;\n        }\n      }\n      return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n      const startOffset = this.getStartOffset(tokenIndex);\n      const endOffset = this.getEndOffset(tokenIndex);\n      const text = this._text.substring(startOffset, endOffset);\n      return text;\n    }\n    forEach(callback) {\n      const tokenCount = this.getCount();\n      for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n        callback(tokenIndex);\n      }\n    }\n  }\n  return LineTokens;\n})();\nclass SliceLineTokens {\n  constructor(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this.languageIdCodec = source.languageIdCodec;\n    this._tokensCount = 0;\n    for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      const tokenStartOffset = source.getStartOffset(i);\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n      this._tokensCount++;\n    }\n  }\n  getMetadata(tokenIndex) {\n    return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n  }\n  getLanguageId(tokenIndex) {\n    return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n  }\n  getLineContent() {\n    return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n  }\n  equals(other) {\n    if (other instanceof SliceLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n    return false;\n  }\n  getCount() {\n    return this._tokensCount;\n  }\n  getStandardTokenType(tokenIndex) {\n    return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n  }\n  getForeground(tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  }\n  getEndOffset(tokenIndex) {\n    const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  }\n  getClassName(tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  }\n  getInlineStyle(tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  }\n  getPresentation(tokenIndex) {\n    return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n  }\n  findTokenIndexAtOffset(offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  }\n  getTokenText(tokenIndex) {\n    const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n    const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n    const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n    let text = this._source.getTokenText(adjustedTokenIndex);\n    if (tokenStartOffset < this._startOffset) {\n      text = text.substring(this._startOffset - tokenStartOffset);\n    }\n    if (tokenEndOffset > this._endOffset) {\n      text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n    }\n    return text;\n  }\n  forEach(callback) {\n    for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n      callback(tokenIndex);\n    }\n  }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n  const lineNumber = position.lineNumber;\n  if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n    return undefined;\n  }\n  model.tokenization.forceTokenization(lineNumber);\n  const lineTokens = model.tokenization.getLineTokens(lineNumber);\n  const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n  const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n  return tokenType;\n}","map":{"version":3,"names":["TokenMetadata","LineTokens","_","defaultTokenMetadata","createEmpty","lineContent","decoder","defaultMetadata","tokens","Uint32Array","length","createFromTextAndMetadata","data","offset","fullText","Array","text","metadata","push","constructor","_lineTokensBrand","undefined","_tokens","_tokensCount","_text","languageIdCodec","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","getLanguageId","languageId","decodeLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","getEndOffset","findTokenIndexAtOffset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SliceLineTokens","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","substring","tokenMetadata","getTokenText","forEach","callback","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min","adjustedTokenIndex","getStandardTokenTypeAtPosition","model","position","lineNumber","tokenization","isCheapToTokenize","forceTokenization","lineTokens","getLineTokens","column","tokenType"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}