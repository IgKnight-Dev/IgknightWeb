{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport class OneSnippet {\n  static #_ = this._decor = {\n    active: ModelDecorationOptions.register({\n      description: 'snippet-placeholder-1',\n      stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n      className: 'snippet-placeholder'\n    }),\n    inactive: ModelDecorationOptions.register({\n      description: 'snippet-placeholder-2',\n      stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n      className: 'snippet-placeholder'\n    }),\n    activeFinal: ModelDecorationOptions.register({\n      description: 'snippet-placeholder-3',\n      stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n      className: 'finish-snippet-placeholder'\n    }),\n    inactiveFinal: ModelDecorationOptions.register({\n      description: 'snippet-placeholder-4',\n      stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n      className: 'finish-snippet-placeholder'\n    })\n  };\n  constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {\n    this._editor = _editor;\n    this._snippet = _snippet;\n    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n    this._offset = -1;\n    this._nestingLevel = 1;\n    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n  initialize(textChange) {\n    this._offset = textChange.newPosition;\n  }\n  dispose() {\n    if (this._placeholderDecorations) {\n      this._editor.removeDecorations([...this._placeholderDecorations.values()]);\n    }\n    this._placeholderGroups.length = 0;\n  }\n  _initDecorations() {\n    if (this._offset === -1) {\n      throw new Error(`Snippet not initialized!`);\n    }\n    if (this._placeholderDecorations) {\n      // already initialized\n      return;\n    }\n    this._placeholderDecorations = new Map();\n    const model = this._editor.getModel();\n    this._editor.changeDecorations(accessor => {\n      // create a decoration for each placeholder\n      for (const placeholder of this._snippet.placeholders) {\n        const placeholderOffset = this._snippet.offset(placeholder);\n        const placeholderLen = this._snippet.fullLen(placeholder);\n        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n        const handle = accessor.addDecoration(range, options);\n        this._placeholderDecorations.set(placeholder, handle);\n      }\n    });\n  }\n  move(fwd) {\n    if (!this._editor.hasModel()) {\n      return [];\n    }\n    this._initDecorations();\n    // Transform placeholder text if necessary\n    if (this._placeholderGroupsIdx >= 0) {\n      const operations = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        // Check if the placeholder has a transformation\n        if (placeholder.transform) {\n          const id = this._placeholderDecorations.get(placeholder);\n          const range = this._editor.getModel().getDecorationRange(id);\n          const currentValue = this._editor.getModel().getValueInRange(range);\n          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n          // fix indentation for transformed lines\n          for (let i = 1; i < transformedValueLines.length; i++) {\n            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n          }\n          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n        }\n      }\n      if (operations.length > 0) {\n        this._editor.executeEdits('snippet.placeholderTransform', operations);\n      }\n    }\n    let couldSkipThisPlaceholder = false;\n    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n      this._placeholderGroupsIdx += 1;\n      couldSkipThisPlaceholder = true;\n    } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n      this._placeholderGroupsIdx -= 1;\n      couldSkipThisPlaceholder = true;\n    } else {\n      // the selection of the current placeholder might\n      // not acurate any more -> simply restore it\n    }\n    const newSelections = this._editor.getModel().changeDecorations(accessor => {\n      const activePlaceholders = new Set();\n      // change stickiness to always grow when typing at its edges\n      // because these decorations represent the currently active\n      // tabstop.\n      // Special case #1: reaching the final tabstop\n      // Special case #2: placeholders enclosing active placeholders\n      const selections = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n        // consider to skip this placeholder index when the decoration\n        // range is empty but when the placeholder wasn't. that's a strong\n        // hint that the placeholder has been deleted. (all placeholder must match this)\n        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n        activePlaceholders.add(placeholder);\n        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n          const id = this._placeholderDecorations.get(enclosingPlaceholder);\n          accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n          activePlaceholders.add(enclosingPlaceholder);\n        }\n      }\n      // change stickness to never grow when typing at its edges\n      // so that in-active tabstops never grow\n      for (const [placeholder, id] of this._placeholderDecorations) {\n        if (!activePlaceholders.has(placeholder)) {\n          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n        }\n      }\n      return selections;\n    });\n    return !couldSkipThisPlaceholder ? newSelections ?? [] : this.move(fwd);\n  }\n  _hasPlaceholderBeenCollapsed(placeholder) {\n    // A placeholder is empty when it wasn't empty when authored but\n    // when its tracking decoration is empty. This also applies to all\n    // potential parent placeholders\n    let marker = placeholder;\n    while (marker) {\n      if (marker instanceof Placeholder) {\n        const id = this._placeholderDecorations.get(marker);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (range.isEmpty() && marker.toString().length > 0) {\n          return true;\n        }\n      }\n      marker = marker.parent;\n    }\n    return false;\n  }\n  get isAtFirstPlaceholder() {\n    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n  }\n  get isAtLastPlaceholder() {\n    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n  }\n  get hasPlaceholder() {\n    return this._snippet.placeholders.length > 0;\n  }\n  /**\n   * A snippet is trivial when it has no placeholder or only a final placeholder at\n   * its very end\n   */\n  get isTrivialSnippet() {\n    if (this._snippet.placeholders.length === 0) {\n      return true;\n    }\n    if (this._snippet.placeholders.length === 1) {\n      const [placeholder] = this._snippet.placeholders;\n      if (placeholder.isFinalTabstop) {\n        if (this._snippet.rightMostDescendant === placeholder) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  computePossibleSelections() {\n    const result = new Map();\n    for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n      let ranges;\n      for (const placeholder of placeholdersWithEqualIndex) {\n        if (placeholder.isFinalTabstop) {\n          // ignore those\n          break;\n        }\n        if (!ranges) {\n          ranges = [];\n          result.set(placeholder.index, ranges);\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n          // one of the placeholder lost its decoration and\n          // therefore we bail out and pretend the placeholder\n          // (with its mirrors) doesn't exist anymore.\n          result.delete(placeholder.index);\n          break;\n        }\n        ranges.push(range);\n      }\n    }\n    return result;\n  }\n  get activeChoice() {\n    if (!this._placeholderDecorations) {\n      return undefined;\n    }\n    const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n    if (!placeholder?.choice) {\n      return undefined;\n    }\n    const id = this._placeholderDecorations.get(placeholder);\n    if (!id) {\n      return undefined;\n    }\n    const range = this._editor.getModel().getDecorationRange(id);\n    if (!range) {\n      return undefined;\n    }\n    return {\n      range,\n      choice: placeholder.choice\n    };\n  }\n  get hasChoice() {\n    let result = false;\n    this._snippet.walk(marker => {\n      result = marker instanceof Choice;\n      return !result;\n    });\n    return result;\n  }\n  merge(others) {\n    const model = this._editor.getModel();\n    this._nestingLevel *= 10;\n    this._editor.changeDecorations(accessor => {\n      // For each active placeholder take one snippet and merge it\n      // in that the placeholder (can be many for `$1foo$1foo`). Because\n      // everything is sorted by editor selection we can simply remove\n      // elements from the beginning of the array\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const nested = others.shift();\n        console.assert(nested._offset !== -1);\n        console.assert(!nested._placeholderDecorations);\n        // Massage placeholder-indicies of the nested snippet to be\n        // sorted right after the insertion point. This ensures we move\n        // through the placeholders in the correct order\n        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n          if (nestedPlaceholder.isFinalTabstop) {\n            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;\n          } else {\n            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;\n          }\n        }\n        this._snippet.replace(placeholder, nested._snippet.children);\n        // Remove the placeholder at which position are inserting\n        // the snippet and also remove its decoration.\n        const id = this._placeholderDecorations.get(placeholder);\n        accessor.removeDecoration(id);\n        this._placeholderDecorations.delete(placeholder);\n        // For each *new* placeholder we create decoration to monitor\n        // how and if it grows/shrinks.\n        for (const placeholder of nested._snippet.placeholders) {\n          const placeholderOffset = nested._snippet.offset(placeholder);\n          const placeholderLen = nested._snippet.fullLen(placeholder);\n          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n          this._placeholderDecorations.set(placeholder, handle);\n        }\n      }\n      // Last, re-create the placeholder groups by sorting placeholders by their index.\n      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n    });\n  }\n}\nconst _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined,\n  overtypingCapturer: undefined\n};\nlet SnippetSession = SnippetSession_1 = class SnippetSession {\n  static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n    const line = model.getLineContent(position.lineNumber);\n    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n    // the snippet as inserted\n    let snippetTextString;\n    snippet.walk(marker => {\n      // all text elements that are not inside choice\n      if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n        return true;\n      }\n      // check with filter (iff provided)\n      if (filter && !filter.has(marker)) {\n        return true;\n      }\n      const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n      if (adjustIndentation) {\n        // adjust indentation of snippet test\n        // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n        // -all N+1 lines get extra-indented and normalized\n        // -the text start get extra-indented and normalized when following a linebreak\n        const offset = snippet.offset(marker);\n        if (offset === 0) {\n          // snippet start\n          lines[0] = model.normalizeIndentation(lines[0]);\n        } else {\n          // check if text start is after a linebreak\n          snippetTextString = snippetTextString ?? snippet.toString();\n          const prevChar = snippetTextString.charCodeAt(offset - 1);\n          if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n          }\n        }\n        for (let i = 1; i < lines.length; i++) {\n          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n        }\n      }\n      const newValue = lines.join(model.getEOL());\n      if (newValue !== marker.value) {\n        marker.parent.replace(marker, [new Text(newValue)]);\n        snippetTextString = undefined;\n      }\n      return true;\n    });\n    return lineLeadingWhitespace;\n  }\n  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n    if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n      // overwrite[Before|After] is compute using the position, not the whole\n      // selection. therefore we adjust the selection around that position\n      const {\n        positionLineNumber,\n        positionColumn\n      } = selection;\n      const positionColumnBefore = positionColumn - overwriteBefore;\n      const positionColumnAfter = positionColumn + overwriteAfter;\n      const range = model.validateRange({\n        startLineNumber: positionLineNumber,\n        startColumn: positionColumnBefore,\n        endLineNumber: positionLineNumber,\n        endColumn: positionColumnAfter\n      });\n      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n    }\n    return selection;\n  }\n  static createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n    const edits = [];\n    const snippets = [];\n    if (!editor.hasModel()) {\n      return {\n        edits,\n        snippets\n      };\n    }\n    const model = editor.getModel();\n    const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n    const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n    const readClipboardText = () => clipboardText;\n    // know what text the overwrite[Before|After] extensions\n    // of the primary curser have selected because only when\n    // secondary selections extend to the same text we can grow them\n    const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n    const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n    // remember the first non-whitespace column to decide if\n    // `keepWhitespace` should be overruled for secondary selections\n    const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n    // sort selections by their start position but remeber\n    // the original index. that allows you to create correct\n    // offset-based selection logic without changing the\n    // primary selection\n    const indexedSelections = editor.getSelections().map((selection, idx) => ({\n      selection,\n      idx\n    })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n    for (const {\n      selection,\n      idx\n    } of indexedSelections) {\n      // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n      // compare if this matches the extensions of the primary selection\n      let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n      let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n        extensionBefore = selection;\n      }\n      if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n        extensionAfter = selection;\n      }\n      // merge the before and after selection into one\n      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n      // adjust the template string to match the indentation and\n      // whitespace rules of this insert location (can be different for each cursor)\n      // happens when being asked for (default) or when this is a secondary\n      // cursor and the leading whitespace is different\n      const start = snippetSelection.getStartPosition();\n      const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), snippet);\n      snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer), new CommentBasedVariableResolver(model, selection, languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService), new RandomBasedVariableResolver()]));\n      // store snippets with the index of their originating selection.\n      // that ensures the primiary cursor stays primary despite not being\n      // the one with lowest start position\n      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n      edits[idx].identifier = {\n        major: idx,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n      edits[idx]._isTracked = true;\n      snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n    }\n    return {\n      edits,\n      snippets\n    };\n  }\n  static createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n    if (!editor.hasModel() || snippetEdits.length === 0) {\n      return {\n        edits: [],\n        snippets: []\n      };\n    }\n    const edits = [];\n    const model = editor.getModel();\n    const parser = new SnippetParser();\n    const snippet = new TextmateSnippet();\n    // snippet variables resolver\n    const resolver = new CompositeSnippetVariableResolver([editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model)), new ClipboardBasedVariableResolver(() => clipboardText, 0, editor.getSelections().length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer), new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService))), new RandomBasedVariableResolver()]);\n    //\n    snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n    let offset = 0;\n    for (let i = 0; i < snippetEdits.length; i++) {\n      const {\n        range,\n        template\n      } = snippetEdits[i];\n      // gaps between snippet edits are appended as text nodes. this\n      // ensures placeholder-offsets are later correct\n      if (i > 0) {\n        const lastRange = snippetEdits[i - 1].range;\n        const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n        const textNode = new Text(model.getValueInRange(textRange));\n        snippet.appendChild(textNode);\n        offset += textNode.value.length;\n      }\n      const newNodes = parser.parseFragment(template, snippet);\n      SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n      snippet.resolveVariables(resolver);\n      const snippetText = snippet.toString();\n      const snippetFragmentText = snippetText.slice(offset);\n      offset = snippetText.length;\n      // make edit\n      const edit = EditOperation.replace(range, snippetFragmentText);\n      edit.identifier = {\n        major: i,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n      edit._isTracked = true;\n      edits.push(edit);\n    }\n    //\n    parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n    return {\n      edits,\n      snippets: [new OneSnippet(editor, snippet, '')]\n    };\n  }\n  constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {\n    this._editor = _editor;\n    this._template = _template;\n    this._options = _options;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._templateMerges = [];\n    this._snippets = [];\n  }\n  dispose() {\n    dispose(this._snippets);\n  }\n  _logInfo() {\n    return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n  }\n  insert() {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    // make insert edit and start with first selections\n    const {\n      edits,\n      snippets\n    } = typeof this._template === 'string' ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);\n    this._snippets = snippets;\n    this._editor.executeEdits('snippet', edits, _undoEdits => {\n      // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n      // so we need to look only at the undo edits relevant for us.\n      // Our edits have an identifier set so that's how we can distinguish them\n      const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n      for (let idx = 0; idx < snippets.length; idx++) {\n        snippets[idx].initialize(undoEdits[idx].textChange);\n      }\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(true);\n      } else {\n        return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n    this._editor.revealRange(this._editor.getSelections()[0]);\n  }\n  merge(template, options = _defaultOptions) {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n    const {\n      edits,\n      snippets\n    } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);\n    this._editor.executeEdits('snippet', edits, _undoEdits => {\n      // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n      // so we need to look only at the undo edits relevant for us.\n      // Our edits have an identifier set so that's how we can distinguish them\n      const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n      for (let idx = 0; idx < snippets.length; idx++) {\n        snippets[idx].initialize(undoEdits[idx].textChange);\n      }\n      // Trivial snippets have no placeholder or are just the final placeholder. That means they\n      // are just text insertions and we don't need to merge the nested snippet into the existing\n      // snippet\n      const isTrivialSnippet = snippets[0].isTrivialSnippet;\n      if (!isTrivialSnippet) {\n        for (const snippet of this._snippets) {\n          snippet.merge(snippets);\n        }\n        console.assert(snippets.length === 0);\n      }\n      if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n        return this._move(undefined);\n      } else {\n        return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n  }\n  next() {\n    const newSelections = this._move(true);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  prev() {\n    const newSelections = this._move(false);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  _move(fwd) {\n    const selections = [];\n    for (const snippet of this._snippets) {\n      const oneSelection = snippet.move(fwd);\n      selections.push(...oneSelection);\n    }\n    return selections;\n  }\n  get isAtFirstPlaceholder() {\n    return this._snippets[0].isAtFirstPlaceholder;\n  }\n  get isAtLastPlaceholder() {\n    return this._snippets[0].isAtLastPlaceholder;\n  }\n  get hasPlaceholder() {\n    return this._snippets[0].hasPlaceholder;\n  }\n  get hasChoice() {\n    return this._snippets[0].hasChoice;\n  }\n  get activeChoice() {\n    return this._snippets[0].activeChoice;\n  }\n  isSelectionWithinPlaceholders() {\n    if (!this.hasPlaceholder) {\n      return false;\n    }\n    const selections = this._editor.getSelections();\n    if (selections.length < this._snippets.length) {\n      // this means we started snippet mode with N\n      // selections and have M (N > M) selections.\n      // So one snippet is without selection -> cancel\n      return false;\n    }\n    const allPossibleSelections = new Map();\n    for (const snippet of this._snippets) {\n      const possibleSelections = snippet.computePossibleSelections();\n      // for the first snippet find the placeholder (and its ranges)\n      // that contain at least one selection. for all remaining snippets\n      // the same placeholder (and their ranges) must be used.\n      if (allPossibleSelections.size === 0) {\n        for (const [index, ranges] of possibleSelections) {\n          ranges.sort(Range.compareRangesUsingStarts);\n          for (const selection of selections) {\n            if (ranges[0].containsRange(selection)) {\n              allPossibleSelections.set(index, []);\n              break;\n            }\n          }\n        }\n      }\n      if (allPossibleSelections.size === 0) {\n        // return false if we couldn't associate a selection to\n        // this (the first) snippet\n        return false;\n      }\n      // add selections from 'this' snippet so that we know all\n      // selections for this placeholder\n      allPossibleSelections.forEach((array, index) => {\n        array.push(...possibleSelections.get(index));\n      });\n    }\n    // sort selections (and later placeholder-ranges). then walk both\n    // arrays and make sure the placeholder-ranges contain the corresponding\n    // selection\n    selections.sort(Range.compareRangesUsingStarts);\n    for (const [index, ranges] of allPossibleSelections) {\n      if (ranges.length !== selections.length) {\n        allPossibleSelections.delete(index);\n        continue;\n      }\n      ranges.sort(Range.compareRangesUsingStarts);\n      for (let i = 0; i < ranges.length; i++) {\n        if (!ranges[i].containsRange(selections[i])) {\n          allPossibleSelections.delete(index);\n          continue;\n        }\n      }\n    }\n    // from all possible selections we have deleted those\n    // that don't match with the current selection. if we don't\n    // have any left, we don't have a selection anymore\n    return allPossibleSelections.size > 0;\n  }\n};\nSnippetSession = SnippetSession_1 = __decorate([__param(3, ILanguageConfigurationService)], SnippetSession);\nexport { SnippetSession };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","SnippetSession_1","groupBy","dispose","getLeadingWhitespace","EditOperation","Range","Selection","ILanguageConfigurationService","ModelDecorationOptions","ILabelService","IWorkspaceContextService","Choice","Placeholder","SnippetParser","Text","TextmateSnippet","ClipboardBasedVariableResolver","CommentBasedVariableResolver","CompositeSnippetVariableResolver","ModelBasedVariableResolver","RandomBasedVariableResolver","SelectionBasedVariableResolver","TimeBasedVariableResolver","WorkspaceBasedVariableResolver","OneSnippet","_","_decor","active","register","description","stickiness","className","inactive","activeFinal","inactiveFinal","constructor","_editor","_snippet","_snippetLineLeadingWhitespace","_offset","_nestingLevel","_placeholderGroups","placeholders","compareByIndex","_placeholderGroupsIdx","initialize","textChange","newPosition","_placeholderDecorations","removeDecorations","values","_initDecorations","Error","Map","model","getModel","changeDecorations","accessor","placeholder","placeholderOffset","offset","placeholderLen","fullLen","range","fromPositions","getPositionAt","options","isFinalTabstop","handle","addDecoration","set","move","fwd","hasModel","operations","transform","id","get","getDecorationRange","currentValue","getValueInRange","transformedValueLines","resolve","split","normalizeIndentation","push","replace","join","getEOL","executeEdits","couldSkipThisPlaceholder","newSelections","activePlaceholders","Set","selections","startLineNumber","startColumn","endLineNumber","endColumn","_hasPlaceholderBeenCollapsed","changeDecorationOptions","add","enclosingPlaceholder","enclosingPlaceholders","has","marker","isEmpty","toString","parent","isAtFirstPlaceholder","isAtLastPlaceholder","hasPlaceholder","isTrivialSnippet","rightMostDescendant","computePossibleSelections","result","placeholdersWithEqualIndex","ranges","index","delete","activeChoice","undefined","choice","hasChoice","walk","merge","others","nested","shift","console","assert","indexLastPlaceholder","placeholderInfo","last","nestedPlaceholder","all","children","removeDecoration","_defaultOptions","overwriteBefore","overwriteAfter","adjustWhitespace","clipboardText","overtypingCapturer","SnippetSession","position","adjustIndentation","snippet","filter","line","getLineContent","lineNumber","lineLeadingWhitespace","column","snippetTextString","lines","value","prevChar","charCodeAt","newValue","adjustSelection","selection","positionLineNumber","positionColumn","positionColumnBefore","positionColumnAfter","validateRange","createWithDirection","getDirection","createEditsAndSnippetsFromSelections","editor","template","enforceFinalTabstop","languageConfigurationService","edits","snippets","workspaceService","invokeWithinContext","modelBasedVariableResolver","readClipboardText","firstBeforeText","getSelection","firstAfterText","firstLineFirstNonWhitespace","getLineFirstNonWhitespaceColumn","indexedSelections","getSelections","map","idx","sort","a","b","compareRangesUsingStarts","extensionBefore","extensionAfter","snippetSelection","setStartPosition","setEndPosition","parse","start","getStartPosition","snippetLineLeadingWhitespace","resolveVariables","getOption","identifier","major","minor","_isTracked","createEditsAndSnippetsFromEdits","snippetEdits","parser","resolver","lastRange","textRange","getEndPosition","textNode","appendChild","newNodes","parseFragment","snippetText","snippetFragmentText","slice","edit","ensureFinalTabstop","_template","_options","_languageConfigurationService","_templateMerges","_snippets","_logInfo","insert","_undoEdits","undoEdits","_move","revealRange","next","setSelections","revealPositionInCenterIfOutsideViewport","getPosition","prev","oneSelection","isSelectionWithinPlaceholders","allPossibleSelections","possibleSelections","size","containsRange","forEach","array"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport class OneSnippet {\n    static { this._decor = {\n        active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n        inactive: ModelDecorationOptions.register({ description: 'snippet-placeholder-2', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n        activeFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-3', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n        inactiveFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-4', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n    }; }\n    constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {\n        this._editor = _editor;\n        this._snippet = _snippet;\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n        this._offset = -1;\n        this._nestingLevel = 1;\n        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n        this._placeholderGroupsIdx = -1;\n    }\n    initialize(textChange) {\n        this._offset = textChange.newPosition;\n    }\n    dispose() {\n        if (this._placeholderDecorations) {\n            this._editor.removeDecorations([...this._placeholderDecorations.values()]);\n        }\n        this._placeholderGroups.length = 0;\n    }\n    _initDecorations() {\n        if (this._offset === -1) {\n            throw new Error(`Snippet not initialized!`);\n        }\n        if (this._placeholderDecorations) {\n            // already initialized\n            return;\n        }\n        this._placeholderDecorations = new Map();\n        const model = this._editor.getModel();\n        this._editor.changeDecorations(accessor => {\n            // create a decoration for each placeholder\n            for (const placeholder of this._snippet.placeholders) {\n                const placeholderOffset = this._snippet.offset(placeholder);\n                const placeholderLen = this._snippet.fullLen(placeholder);\n                const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n                const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                const handle = accessor.addDecoration(range, options);\n                this._placeholderDecorations.set(placeholder, handle);\n            }\n        });\n    }\n    move(fwd) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this._initDecorations();\n        // Transform placeholder text if necessary\n        if (this._placeholderGroupsIdx >= 0) {\n            const operations = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                // Check if the placeholder has a transformation\n                if (placeholder.transform) {\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    const currentValue = this._editor.getModel().getValueInRange(range);\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n                    // fix indentation for transformed lines\n                    for (let i = 1; i < transformedValueLines.length; i++) {\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n                    }\n                    operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n                }\n            }\n            if (operations.length > 0) {\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\n            }\n        }\n        let couldSkipThisPlaceholder = false;\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n            this._placeholderGroupsIdx += 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\n            this._placeholderGroupsIdx -= 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else {\n            // the selection of the current placeholder might\n            // not acurate any more -> simply restore it\n        }\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\n            const activePlaceholders = new Set();\n            // change stickiness to always grow when typing at its edges\n            // because these decorations represent the currently active\n            // tabstop.\n            // Special case #1: reaching the final tabstop\n            // Special case #2: placeholders enclosing active placeholders\n            const selections = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                // consider to skip this placeholder index when the decoration\n                // range is empty but when the placeholder wasn't. that's a strong\n                // hint that the placeholder has been deleted. (all placeholder must match this)\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(placeholder);\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(enclosingPlaceholder);\n                }\n            }\n            // change stickness to never grow when typing at its edges\n            // so that in-active tabstops never grow\n            for (const [placeholder, id] of this._placeholderDecorations) {\n                if (!activePlaceholders.has(placeholder)) {\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                }\n            }\n            return selections;\n        });\n        return !couldSkipThisPlaceholder ? newSelections ?? [] : this.move(fwd);\n    }\n    _hasPlaceholderBeenCollapsed(placeholder) {\n        // A placeholder is empty when it wasn't empty when authored but\n        // when its tracking decoration is empty. This also applies to all\n        // potential parent placeholders\n        let marker = placeholder;\n        while (marker) {\n            if (marker instanceof Placeholder) {\n                const id = this._placeholderDecorations.get(marker);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (range.isEmpty() && marker.toString().length > 0) {\n                    return true;\n                }\n            }\n            marker = marker.parent;\n        }\n        return false;\n    }\n    get isAtFirstPlaceholder() {\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    }\n    get isAtLastPlaceholder() {\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    }\n    get hasPlaceholder() {\n        return this._snippet.placeholders.length > 0;\n    }\n    /**\n     * A snippet is trivial when it has no placeholder or only a final placeholder at\n     * its very end\n     */\n    get isTrivialSnippet() {\n        if (this._snippet.placeholders.length === 0) {\n            return true;\n        }\n        if (this._snippet.placeholders.length === 1) {\n            const [placeholder] = this._snippet.placeholders;\n            if (placeholder.isFinalTabstop) {\n                if (this._snippet.rightMostDescendant === placeholder) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    computePossibleSelections() {\n        const result = new Map();\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n            let ranges;\n            for (const placeholder of placeholdersWithEqualIndex) {\n                if (placeholder.isFinalTabstop) {\n                    // ignore those\n                    break;\n                }\n                if (!ranges) {\n                    ranges = [];\n                    result.set(placeholder.index, ranges);\n                }\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (!range) {\n                    // one of the placeholder lost its decoration and\n                    // therefore we bail out and pretend the placeholder\n                    // (with its mirrors) doesn't exist anymore.\n                    result.delete(placeholder.index);\n                    break;\n                }\n                ranges.push(range);\n            }\n        }\n        return result;\n    }\n    get activeChoice() {\n        if (!this._placeholderDecorations) {\n            return undefined;\n        }\n        const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n        if (!placeholder?.choice) {\n            return undefined;\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        if (!id) {\n            return undefined;\n        }\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n            return undefined;\n        }\n        return { range, choice: placeholder.choice };\n    }\n    get hasChoice() {\n        let result = false;\n        this._snippet.walk(marker => {\n            result = marker instanceof Choice;\n            return !result;\n        });\n        return result;\n    }\n    merge(others) {\n        const model = this._editor.getModel();\n        this._nestingLevel *= 10;\n        this._editor.changeDecorations(accessor => {\n            // For each active placeholder take one snippet and merge it\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\n            // everything is sorted by editor selection we can simply remove\n            // elements from the beginning of the array\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const nested = others.shift();\n                console.assert(nested._offset !== -1);\n                console.assert(!nested._placeholderDecorations);\n                // Massage placeholder-indicies of the nested snippet to be\n                // sorted right after the insertion point. This ensures we move\n                // through the placeholders in the correct order\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n                    if (nestedPlaceholder.isFinalTabstop) {\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n                    }\n                    else {\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n                    }\n                }\n                this._snippet.replace(placeholder, nested._snippet.children);\n                // Remove the placeholder at which position are inserting\n                // the snippet and also remove its decoration.\n                const id = this._placeholderDecorations.get(placeholder);\n                accessor.removeDecoration(id);\n                this._placeholderDecorations.delete(placeholder);\n                // For each *new* placeholder we create decoration to monitor\n                // how and if it grows/shrinks.\n                for (const placeholder of nested._snippet.placeholders) {\n                    const placeholderOffset = nested._snippet.offset(placeholder);\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\n                    const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                    const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                    this._placeholderDecorations.set(placeholder, handle);\n                }\n            }\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\n            this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n        });\n    }\n}\nconst _defaultOptions = {\n    overwriteBefore: 0,\n    overwriteAfter: 0,\n    adjustWhitespace: true,\n    clipboardText: undefined,\n    overtypingCapturer: undefined\n};\nlet SnippetSession = SnippetSession_1 = class SnippetSession {\n    static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n        const line = model.getLineContent(position.lineNumber);\n        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n        // the snippet as inserted\n        let snippetTextString;\n        snippet.walk(marker => {\n            // all text elements that are not inside choice\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n                return true;\n            }\n            // check with filter (iff provided)\n            if (filter && !filter.has(marker)) {\n                return true;\n            }\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n            if (adjustIndentation) {\n                // adjust indentation of snippet test\n                // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n                // -all N+1 lines get extra-indented and normalized\n                // -the text start get extra-indented and normalized when following a linebreak\n                const offset = snippet.offset(marker);\n                if (offset === 0) {\n                    // snippet start\n                    lines[0] = model.normalizeIndentation(lines[0]);\n                }\n                else {\n                    // check if text start is after a linebreak\n                    snippetTextString = snippetTextString ?? snippet.toString();\n                    const prevChar = snippetTextString.charCodeAt(offset - 1);\n                    if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n                    }\n                }\n                for (let i = 1; i < lines.length; i++) {\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n                }\n            }\n            const newValue = lines.join(model.getEOL());\n            if (newValue !== marker.value) {\n                marker.parent.replace(marker, [new Text(newValue)]);\n                snippetTextString = undefined;\n            }\n            return true;\n        });\n        return lineLeadingWhitespace;\n    }\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n            // overwrite[Before|After] is compute using the position, not the whole\n            // selection. therefore we adjust the selection around that position\n            const { positionLineNumber, positionColumn } = selection;\n            const positionColumnBefore = positionColumn - overwriteBefore;\n            const positionColumnAfter = positionColumn + overwriteAfter;\n            const range = model.validateRange({\n                startLineNumber: positionLineNumber,\n                startColumn: positionColumnBefore,\n                endLineNumber: positionLineNumber,\n                endColumn: positionColumnAfter\n            });\n            selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n        }\n        return selection;\n    }\n    static createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        const edits = [];\n        const snippets = [];\n        if (!editor.hasModel()) {\n            return { edits, snippets };\n        }\n        const model = editor.getModel();\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n        const readClipboardText = () => clipboardText;\n        // know what text the overwrite[Before|After] extensions\n        // of the primary curser have selected because only when\n        // secondary selections extend to the same text we can grow them\n        const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n        const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n        // remember the first non-whitespace column to decide if\n        // `keepWhitespace` should be overruled for secondary selections\n        const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n        // sort selections by their start position but remeber\n        // the original index. that allows you to create correct\n        // offset-based selection logic without changing the\n        // primary selection\n        const indexedSelections = editor.getSelections()\n            .map((selection, idx) => ({ selection, idx }))\n            .sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        for (const { selection, idx } of indexedSelections) {\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n            // compare if this matches the extensions of the primary selection\n            let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n            let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                extensionBefore = selection;\n            }\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                extensionAfter = selection;\n            }\n            // merge the before and after selection into one\n            const snippetSelection = selection\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n            // adjust the template string to match the indentation and\n            // whitespace rules of this insert location (can be different for each cursor)\n            // happens when being asked for (default) or when this is a secondary\n            // cursor and the leading whitespace is different\n            const start = snippetSelection.getStartPosition();\n            const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), snippet);\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\n                modelBasedVariableResolver,\n                new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'),\n                new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\n                new CommentBasedVariableResolver(model, selection, languageConfigurationService),\n                new TimeBasedVariableResolver,\n                new WorkspaceBasedVariableResolver(workspaceService),\n                new RandomBasedVariableResolver,\n            ]));\n            // store snippets with the index of their originating selection.\n            // that ensures the primiary cursor stays primary despite not being\n            // the one with lowest start position\n            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edits[idx]._isTracked = true;\n            snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n        }\n        return { edits, snippets };\n    }\n    static createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        if (!editor.hasModel() || snippetEdits.length === 0) {\n            return { edits: [], snippets: [] };\n        }\n        const edits = [];\n        const model = editor.getModel();\n        const parser = new SnippetParser();\n        const snippet = new TextmateSnippet();\n        // snippet variables resolver\n        const resolver = new CompositeSnippetVariableResolver([\n            editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),\n            new ClipboardBasedVariableResolver(() => clipboardText, 0, editor.getSelections().length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'),\n            new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer),\n            new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService),\n            new TimeBasedVariableResolver,\n            new WorkspaceBasedVariableResolver(editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService))),\n            new RandomBasedVariableResolver,\n        ]);\n        //\n        snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n        let offset = 0;\n        for (let i = 0; i < snippetEdits.length; i++) {\n            const { range, template } = snippetEdits[i];\n            // gaps between snippet edits are appended as text nodes. this\n            // ensures placeholder-offsets are later correct\n            if (i > 0) {\n                const lastRange = snippetEdits[i - 1].range;\n                const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n                const textNode = new Text(model.getValueInRange(textRange));\n                snippet.appendChild(textNode);\n                offset += textNode.value.length;\n            }\n            const newNodes = parser.parseFragment(template, snippet);\n            SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n            snippet.resolveVariables(resolver);\n            const snippetText = snippet.toString();\n            const snippetFragmentText = snippetText.slice(offset);\n            offset = snippetText.length;\n            // make edit\n            const edit = EditOperation.replace(range, snippetFragmentText);\n            edit.identifier = { major: i, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edit._isTracked = true;\n            edits.push(edit);\n        }\n        //\n        parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n        return {\n            edits,\n            snippets: [new OneSnippet(editor, snippet, '')]\n        };\n    }\n    constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {\n        this._editor = _editor;\n        this._template = _template;\n        this._options = _options;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._templateMerges = [];\n        this._snippets = [];\n    }\n    dispose() {\n        dispose(this._snippets);\n    }\n    _logInfo() {\n        return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n    }\n    insert() {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        // make insert edit and start with first selections\n        const { edits, snippets } = typeof this._template === 'string'\n            ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService)\n            : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);\n        this._snippets = snippets;\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            if (this._snippets[0].hasPlaceholder) {\n                return this._move(true);\n            }\n            else {\n                return undoEdits\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n        this._editor.revealRange(this._editor.getSelections()[0]);\n    }\n    merge(template, options = _defaultOptions) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n        const { edits, snippets } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            // Trivial snippets have no placeholder or are just the final placeholder. That means they\n            // are just text insertions and we don't need to merge the nested snippet into the existing\n            // snippet\n            const isTrivialSnippet = snippets[0].isTrivialSnippet;\n            if (!isTrivialSnippet) {\n                for (const snippet of this._snippets) {\n                    snippet.merge(snippets);\n                }\n                console.assert(snippets.length === 0);\n            }\n            if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n                return this._move(undefined);\n            }\n            else {\n                return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n    }\n    next() {\n        const newSelections = this._move(true);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    prev() {\n        const newSelections = this._move(false);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    _move(fwd) {\n        const selections = [];\n        for (const snippet of this._snippets) {\n            const oneSelection = snippet.move(fwd);\n            selections.push(...oneSelection);\n        }\n        return selections;\n    }\n    get isAtFirstPlaceholder() {\n        return this._snippets[0].isAtFirstPlaceholder;\n    }\n    get isAtLastPlaceholder() {\n        return this._snippets[0].isAtLastPlaceholder;\n    }\n    get hasPlaceholder() {\n        return this._snippets[0].hasPlaceholder;\n    }\n    get hasChoice() {\n        return this._snippets[0].hasChoice;\n    }\n    get activeChoice() {\n        return this._snippets[0].activeChoice;\n    }\n    isSelectionWithinPlaceholders() {\n        if (!this.hasPlaceholder) {\n            return false;\n        }\n        const selections = this._editor.getSelections();\n        if (selections.length < this._snippets.length) {\n            // this means we started snippet mode with N\n            // selections and have M (N > M) selections.\n            // So one snippet is without selection -> cancel\n            return false;\n        }\n        const allPossibleSelections = new Map();\n        for (const snippet of this._snippets) {\n            const possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n                for (const [index, ranges] of possibleSelections) {\n                    ranges.sort(Range.compareRangesUsingStarts);\n                    for (const selection of selections) {\n                        if (ranges[0].containsRange(selection)) {\n                            allPossibleSelections.set(index, []);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (allPossibleSelections.size === 0) {\n                // return false if we couldn't associate a selection to\n                // this (the first) snippet\n                return false;\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach((array, index) => {\n                array.push(...possibleSelections.get(index));\n            });\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n        selections.sort(Range.compareRangesUsingStarts);\n        for (const [index, ranges] of allPossibleSelections) {\n            if (ranges.length !== selections.length) {\n                allPossibleSelections.delete(index);\n                continue;\n            }\n            ranges.sort(Range.compareRangesUsingStarts);\n            for (let i = 0; i < ranges.length; i++) {\n                if (!ranges[i].containsRange(selections[i])) {\n                    allPossibleSelections.delete(index);\n                    continue;\n                }\n            }\n        }\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n        return allPossibleSelections.size > 0;\n    }\n};\nSnippetSession = SnippetSession_1 = __decorate([\n    __param(3, ILanguageConfigurationService)\n], SnippetSession);\nexport { SnippetSession };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}