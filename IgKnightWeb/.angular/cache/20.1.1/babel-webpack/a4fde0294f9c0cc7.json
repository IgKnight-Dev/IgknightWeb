{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nexport function isThenable(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      reject(new CancellationError());\n    });\n    Promise.resolve(thenable).then(value => {\n      subscription.dispose();\n      source.dispose();\n      resolve(value);\n    }, err => {\n      subscription.dispose();\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n      source.dispose();\n    }\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n  }();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return new Promise((resolve, reject) => {\n    const ref = token.onCancellationRequested(() => {\n      ref.dispose();\n      resolve(defaultValue);\n    });\n    promise.then(resolve, reject).finally(() => ref.dispose());\n  });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n  constructor() {\n    this.isDisposed = false;\n    this.activePromise = null;\n    this.queuedPromise = null;\n    this.queuedPromiseFactory = null;\n  }\n  queue(promiseFactory) {\n    if (this.isDisposed) {\n      return Promise.reject(new Error('Throttler is disposed'));\n    }\n    if (this.activePromise) {\n      this.queuedPromiseFactory = promiseFactory;\n      if (!this.queuedPromise) {\n        const onComplete = () => {\n          this.queuedPromise = null;\n          if (this.isDisposed) {\n            return;\n          }\n          const result = this.queue(this.queuedPromiseFactory);\n          this.queuedPromiseFactory = null;\n          return result;\n        };\n        this.queuedPromise = new Promise(resolve => {\n          this.activePromise.then(onComplete, onComplete).then(resolve);\n        });\n      }\n      return new Promise((resolve, reject) => {\n        this.queuedPromise.then(resolve, reject);\n      });\n    }\n    this.activePromise = promiseFactory();\n    return new Promise((resolve, reject) => {\n      this.activePromise.then(result => {\n        this.activePromise = null;\n        resolve(result);\n      }, err => {\n        this.activePromise = null;\n        reject(err);\n      });\n    });\n  }\n  dispose() {\n    this.isDisposed = true;\n  }\n}\nconst timeoutDeferred = (timeout, fn) => {\n  let scheduled = true;\n  const handle = setTimeout(() => {\n    scheduled = false;\n    fn();\n  }, timeout);\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      clearTimeout(handle);\n      scheduled = false;\n    }\n  };\n};\nconst microtaskDeferred = fn => {\n  let scheduled = true;\n  queueMicrotask(() => {\n    if (scheduled) {\n      scheduled = false;\n      fn();\n    }\n  });\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      scheduled = false;\n    }\n  };\n};\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.deferred = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n  trigger(task, delay = this.defaultDelay) {\n    this.task = task;\n    this.cancelTimeout();\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n        return undefined;\n      });\n    }\n    const fn = () => {\n      this.deferred = null;\n      this.doResolve?.(null);\n    };\n    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n    return this.completionPromise;\n  }\n  isTriggered() {\n    return !!this.deferred?.isTriggered();\n  }\n  cancel() {\n    this.cancelTimeout();\n    if (this.completionPromise) {\n      this.doReject?.(new CancellationError());\n      this.completionPromise = null;\n    }\n  }\n  cancelTimeout() {\n    this.deferred?.dispose();\n    this.deferred = null;\n  }\n  dispose() {\n    this.cancel();\n  }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n  constructor(defaultDelay) {\n    this.delayer = new Delayer(defaultDelay);\n    this.throttler = new Throttler();\n  }\n  trigger(promiseFactory, delay) {\n    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n  }\n  cancel() {\n    this.delayer.cancel();\n  }\n  dispose() {\n    this.delayer.dispose();\n    this.throttler.dispose();\n  }\n}\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(() => {\n      disposable.dispose();\n      resolve();\n    }, millis);\n    const disposable = token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      disposable.dispose();\n      reject(new CancellationError());\n    });\n  });\n}\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler, timeout = 0, store) {\n  const timer = setTimeout(() => {\n    handler();\n    if (store) {\n      disposable.dispose();\n    }\n  }, timeout);\n  const disposable = toDisposable(() => {\n    clearTimeout(timer);\n    store?.deleteAndLeak(disposable);\n  });\n  store?.add(disposable);\n  return disposable;\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n  let index = 0;\n  const len = promiseFactories.length;\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n      return loop();\n    });\n  };\n  return loop();\n}\nexport class TimeoutTimer {\n  constructor(runner, timeout) {\n    this._isDisposed = false;\n    this._token = -1;\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n  dispose() {\n    this.cancel();\n    this._isDisposed = true;\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, timeout) {\n    if (this._isDisposed) {\n      throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n    }\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n  setIfNotSet(runner, timeout) {\n    if (this._isDisposed) {\n      throw new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n    }\n    if (this._token !== -1) {\n      // timer is already set\n      return;\n    }\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n}\nexport class IntervalTimer {\n  constructor() {\n    this.disposable = undefined;\n    this.isDisposed = false;\n  }\n  cancel() {\n    this.disposable?.dispose();\n    this.disposable = undefined;\n  }\n  cancelAndSet(runner, interval, context = globalThis) {\n    if (this.isDisposed) {\n      throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n    }\n    this.cancel();\n    const handle = context.setInterval(() => {\n      runner();\n    }, interval);\n    this.disposable = toDisposable(() => {\n      context.clearInterval(handle);\n      this.disposable = undefined;\n    });\n  }\n  dispose() {\n    this.cancel();\n    this.isDisposed = true;\n  }\n}\nexport class RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\n   * Dispose RunOnceScheduler\n   */\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  /**\n   * Cancel current scheduled runner (if any).\n   */\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  /**\n   * Cancel previous runner (if any) & schedule a new runner.\n   */\n  schedule(delay = this.timeout) {\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n  get delay() {\n    return this.timeout;\n  }\n  set delay(value) {\n    this.timeout = value;\n  }\n  /**\n   * Returns true if scheduled.\n   */\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n  onTimeout() {\n    this.timeoutToken = -1;\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n  doRun() {\n    this.runner?.();\n  }\n}\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle;\nexport let _runWhenIdle;\n(function () {\n  if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n    _runWhenIdle = (_targetWindow, runner) => {\n      setTimeout0(() => {\n        if (disposed) {\n          return;\n        }\n        const end = Date.now() + 15; // one frame at 64fps\n        const deadline = {\n          didTimeout: true,\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n        };\n        runner(Object.freeze(deadline));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n        }\n      };\n    };\n  } else {\n    _runWhenIdle = (targetWindow, runner, timeout) => {\n      const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          targetWindow.cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n  runWhenGlobalIdle = runner => _runWhenIdle(globalThis, runner);\n})();\nexport class AbstractIdleValue {\n  constructor(targetWindow, executor) {\n    this._didRun = false;\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n    this._handle = _runWhenIdle(targetWindow, () => this._executor());\n  }\n  dispose() {\n    this._handle.dispose();\n  }\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n      this._executor();\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n  get isInitialized() {\n    return this._didRun;\n  }\n}\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue extends AbstractIdleValue {\n  constructor(executor) {\n    super(globalThis, executor);\n  }\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise {\n  get isRejected() {\n    return this.outcome?.outcome === 1 /* DeferredOutcome.Rejected */;\n  }\n  get isSettled() {\n    return !!this.outcome;\n  }\n  constructor() {\n    this.p = new Promise((c, e) => {\n      this.completeCallback = c;\n      this.errorCallback = e;\n    });\n  }\n  complete(value) {\n    return new Promise(resolve => {\n      this.completeCallback(value);\n      this.outcome = {\n        outcome: 0 /* DeferredOutcome.Resolved */,\n        value\n      };\n      resolve();\n    });\n  }\n  error(err) {\n    return new Promise(resolve => {\n      this.errorCallback(err);\n      this.outcome = {\n        outcome: 1 /* DeferredOutcome.Rejected */,\n        value: err\n      };\n      resolve();\n    });\n  }\n  cancel() {\n    return this.error(new CancellationError());\n  }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n  /**\n   * A drop-in replacement for `Promise.all` with the only difference\n   * that the method awaits every promise to either fulfill or reject.\n   *\n   * Similar to `Promise.all`, only the first error will be returned\n   * if any.\n   */\n  function settled(_x) {\n    return _settled.apply(this, arguments);\n  }\n  function _settled() {\n    _settled = _asyncToGenerator(function* (promises) {\n      let firstError = undefined;\n      const result = yield Promise.all(promises.map(promise => promise.then(value => value, error => {\n        if (!firstError) {\n          firstError = error;\n        }\n        return undefined; // do not rethrow so that other promises can settle\n      })));\n      if (typeof firstError !== 'undefined') {\n        throw firstError;\n      }\n      return result; // cast is needed and protected by the `throw` above\n    });\n    return _settled.apply(this, arguments);\n  }\n  Promises.settled = settled;\n  /**\n   * A helper to create a new `Promise<T>` with a body that is a promise\n   * itself. By default, an error that raises from the async body will\n   * end up as a unhandled rejection, so this utility properly awaits the\n   * body and rejects the promise as a normal promise does without async\n   * body.\n   *\n   * This method should only be used in rare cases where otherwise `async`\n   * cannot be used (e.g. when callbacks are involved that require this).\n   */\n  function withAsyncBody(bodyFn) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(/*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (resolve, reject) {\n        try {\n          yield bodyFn(resolve, reject);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      return function (_x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n  Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject {\n  static fromArray(items) {\n    return new AsyncIterableObject(writer => {\n      writer.emitMany(items);\n    });\n  }\n  static fromPromise(promise) {\n    return new AsyncIterableObject(/*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (emitter) {\n        emitter.emitMany(yield promise);\n      });\n      return function (_x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  }\n  static fromPromises(promises) {\n    return new AsyncIterableObject(/*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (emitter) {\n        yield Promise.all(promises.map(/*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (p) {\n            return emitter.emitOne(yield p);\n          });\n          return function (_x6) {\n            return _ref4.apply(this, arguments);\n          };\n        }()));\n      });\n      return function (_x5) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  }\n  static merge(iterables) {\n    return new AsyncIterableObject(/*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (emitter) {\n        yield Promise.all(iterables.map(/*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator(function* (iterable) {\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n              for (var _iterator = _asyncIterator(iterable), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const item = _step.value;\n                {\n                  emitter.emitOne(item);\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n          return function (_x8) {\n            return _ref6.apply(this, arguments);\n          };\n        }()));\n      });\n      return function (_x7) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n  }\n  static #_ = this.EMPTY = AsyncIterableObject.fromArray([]);\n  constructor(executor, onReturn) {\n    var _this = this;\n    this._state = 0 /* AsyncIterableSourceState.Initial */;\n    this._results = [];\n    this._error = null;\n    this._onReturn = onReturn;\n    this._onStateChanged = new Emitter();\n    queueMicrotask(/*#__PURE__*/_asyncToGenerator(function* () {\n      const writer = {\n        emitOne: item => _this.emitOne(item),\n        emitMany: items => _this.emitMany(items),\n        reject: error => _this.reject(error)\n      };\n      try {\n        yield Promise.resolve(executor(writer));\n        _this.resolve();\n      } catch (err) {\n        _this.reject(err);\n      } finally {\n        writer.emitOne = undefined;\n        writer.emitMany = undefined;\n        writer.reject = undefined;\n      }\n    }));\n  }\n  [Symbol.asyncIterator]() {\n    var _this2 = this;\n    let i = 0;\n    return {\n      next: function () {\n        var _ref8 = _asyncToGenerator(function* () {\n          do {\n            if (_this2._state === 2 /* AsyncIterableSourceState.DoneError */) {\n              throw _this2._error;\n            }\n            if (i < _this2._results.length) {\n              return {\n                done: false,\n                value: _this2._results[i++]\n              };\n            }\n            if (_this2._state === 1 /* AsyncIterableSourceState.DoneOK */) {\n              return {\n                done: true,\n                value: undefined\n              };\n            }\n            yield Event.toPromise(_this2._onStateChanged.event);\n          } while (true);\n        });\n        return function next() {\n          return _ref8.apply(this, arguments);\n        };\n      }(),\n      return: function () {\n        var _ref9 = _asyncToGenerator(function* () {\n          _this2._onReturn?.();\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n        return function _return() {\n          return _ref9.apply(this, arguments);\n        };\n      }()\n    };\n  }\n  static map(iterable, mapFn) {\n    return new AsyncIterableObject(/*#__PURE__*/function () {\n      var _ref0 = _asyncToGenerator(function* (emitter) {\n        var _iteratorAbruptCompletion2 = false;\n        var _didIteratorError2 = false;\n        var _iteratorError2;\n        try {\n          for (var _iterator2 = _asyncIterator(iterable), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n            const item = _step2.value;\n            {\n              emitter.emitOne(mapFn(item));\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n              yield _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      });\n      return function (_x9) {\n        return _ref0.apply(this, arguments);\n      };\n    }());\n  }\n  map(mapFn) {\n    return AsyncIterableObject.map(this, mapFn);\n  }\n  static filter(iterable, filterFn) {\n    return new AsyncIterableObject(/*#__PURE__*/function () {\n      var _ref1 = _asyncToGenerator(function* (emitter) {\n        var _iteratorAbruptCompletion3 = false;\n        var _didIteratorError3 = false;\n        var _iteratorError3;\n        try {\n          for (var _iterator3 = _asyncIterator(iterable), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _iterator3.next()).done; _iteratorAbruptCompletion3 = false) {\n            const item = _step3.value;\n            {\n              if (filterFn(item)) {\n                emitter.emitOne(item);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n              yield _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      });\n      return function (_x0) {\n        return _ref1.apply(this, arguments);\n      };\n    }());\n  }\n  filter(filterFn) {\n    return AsyncIterableObject.filter(this, filterFn);\n  }\n  static coalesce(iterable) {\n    return AsyncIterableObject.filter(iterable, item => !!item);\n  }\n  coalesce() {\n    return AsyncIterableObject.coalesce(this);\n  }\n  static toPromise(iterable) {\n    return _asyncToGenerator(function* () {\n      const result = [];\n      var _iteratorAbruptCompletion4 = false;\n      var _didIteratorError4 = false;\n      var _iteratorError4;\n      try {\n        for (var _iterator4 = _asyncIterator(iterable), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _iterator4.next()).done; _iteratorAbruptCompletion4 = false) {\n          const item = _step4.value;\n          {\n            result.push(item);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion4 && _iterator4.return != null) {\n            yield _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n      return result;\n    })();\n  }\n  toPromise() {\n    return AsyncIterableObject.toPromise(this);\n  }\n  /**\n   * The value will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitOne(value) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n    this._results.push(value);\n    this._onStateChanged.fire();\n  }\n  /**\n   * The values will be appended at the end.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  emitMany(values) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    // it is important to add new values at the end,\n    // as we may have iterators already running on the array\n    this._results = this._results.concat(values);\n    this._onStateChanged.fire();\n  }\n  /**\n   * Calling `resolve()` will mark the result array as complete.\n   *\n   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  resolve() {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    this._state = 1 /* AsyncIterableSourceState.DoneOK */;\n    this._onStateChanged.fire();\n  }\n  /**\n   * Writing an error will permanently invalidate this iterable.\n   * The current users will receive an error thrown, as will all future users.\n   *\n   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n   */\n  reject(error) {\n    if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n      return;\n    }\n    this._state = 2 /* AsyncIterableSourceState.DoneError */;\n    this._error = error;\n    this._onStateChanged.fire();\n  }\n}\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n  constructor(_source, executor) {\n    super(executor);\n    this._source = _source;\n  }\n  cancel() {\n    this._source.cancel();\n  }\n}\nexport function createCancelableAsyncIterable(callback) {\n  const source = new CancellationTokenSource();\n  const innerIterable = callback(source.token);\n  return new CancelableAsyncIterableObject(source, /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator(function* (emitter) {\n      const subscription = source.token.onCancellationRequested(() => {\n        subscription.dispose();\n        source.dispose();\n        emitter.reject(new CancellationError());\n      });\n      try {\n        var _iteratorAbruptCompletion5 = false;\n        var _didIteratorError5 = false;\n        var _iteratorError5;\n        try {\n          for (var _iterator5 = _asyncIterator(innerIterable), _step5; _iteratorAbruptCompletion5 = !(_step5 = yield _iterator5.next()).done; _iteratorAbruptCompletion5 = false) {\n            const item = _step5.value;\n            {\n              if (source.token.isCancellationRequested) {\n                // canceled in the meantime\n                return;\n              }\n              emitter.emitOne(item);\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion5 && _iterator5.return != null) {\n              yield _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n        subscription.dispose();\n        source.dispose();\n      } catch (err) {\n        subscription.dispose();\n        source.dispose();\n        emitter.reject(err);\n      }\n    });\n    return function (_x1) {\n      return _ref10.apply(this, arguments);\n    };\n  }());\n}\n//#endregion","map":{"version":3,"names":["CancellationTokenSource","BugIndicatingError","CancellationError","Emitter","Event","toDisposable","setTimeout0","MicrotaskDelay","isThenable","obj","then","createCancelablePromise","callback","source","thenable","token","promise","Promise","resolve","reject","subscription","onCancellationRequested","dispose","value","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","ref","Throttler","constructor","isDisposed","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","Error","onComplete","result","timeoutDeferred","timeout","fn","scheduled","handle","setTimeout","isTriggered","clearTimeout","microtaskDeferred","queueMicrotask","Delayer","defaultDelay","deferred","completionPromise","doResolve","doReject","task","trigger","delay","cancelTimeout","ThrottledDelayer","delayer","throttler","millis","disposable","disposableTimeout","handler","store","timer","deleteAndLeak","add","first","promiseFactories","shouldStop","t","index","len","length","loop","factory","TimeoutTimer","runner","_isDisposed","_token","setIfNotSet","cancelAndSet","IntervalTimer","interval","context","globalThis","setInterval","clearInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","schedule","doRun","runWhenGlobalIdle","_runWhenIdle","requestIdleCallback","cancelIdleCallback","_targetWindow","disposed","end","Date","now","deadline","didTimeout","timeRemaining","Math","max","Object","freeze","targetWindow","AbstractIdleValue","executor","_didRun","_executor","_value","_error","_handle","isInitialized","GlobalIdleValue","DeferredPromise","isRejected","outcome","isSettled","p","c","e","completeCallback","errorCallback","complete","error","Promises","settled","_x","_settled","apply","arguments","_asyncToGenerator","promises","firstError","all","map","withAsyncBody","bodyFn","_ref","_x2","_x3","AsyncIterableObject","fromArray","items","writer","emitMany","fromPromise","_ref2","emitter","_x4","fromPromises","_ref3","_ref4","emitOne","_x6","_x5","merge","iterables","_ref5","_ref6","iterable","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","item","return","_x8","_x7","_","EMPTY","onReturn","_this","_state","_results","_onReturn","_onStateChanged","Symbol","asyncIterator","_this2","i","_ref8","toPromise","event","_ref9","mapFn","_ref0","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_x9","filter","filterFn","_ref1","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_x0","coalesce","_iteratorAbruptCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","push","fire","values","concat","CancelableAsyncIterableObject","_source","createCancelableAsyncIterable","innerIterable","_ref10","_iteratorAbruptCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","isCancellationRequested","_x1"],"sources":["C:/Users/abhis/OneDrive/Desktop/IgKnightWeb/IgKnightWeb/node_modules/monaco-editor/esm/vs/base/common/async.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from './cancellation.js';\nimport { BugIndicatingError, CancellationError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable } from './lifecycle.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nexport function isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n    const source = new CancellationTokenSource();\n    const thenable = callback(source.token);\n    const promise = new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            reject(new CancellationError());\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    });\n    return new class {\n        cancel() {\n            source.cancel();\n            source.dispose();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    };\n}\nexport function raceCancellation(promise, token, defaultValue) {\n    return new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            resolve(defaultValue);\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    });\n}\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n    constructor() {\n        this.isDisposed = false;\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.isDisposed) {\n            return Promise.reject(new Error('Throttler is disposed'));\n        }\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    if (this.isDisposed) {\n                        return;\n                    }\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                });\n            }\n            return new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            });\n        }\n        this.activePromise = promiseFactory();\n        return new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        });\n    }\n    dispose() {\n        this.isDisposed = true;\n    }\n}\nconst timeoutDeferred = (timeout, fn) => {\n    let scheduled = true;\n    const handle = setTimeout(() => {\n        scheduled = false;\n        fn();\n    }, timeout);\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => {\n            clearTimeout(handle);\n            scheduled = false;\n        },\n    };\n};\nconst microtaskDeferred = (fn) => {\n    let scheduled = true;\n    queueMicrotask(() => {\n        if (scheduled) {\n            scheduled = false;\n            fn();\n        }\n    });\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => { scheduled = false; },\n    };\n};\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.deferred = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            }).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        const fn = () => {\n            this.deferred = null;\n            this.doResolve?.(null);\n        };\n        this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return !!this.deferred?.isTriggered();\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.doReject?.(new CancellationError());\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        this.deferred?.dispose();\n        this.deferred = null;\n    }\n    dispose() {\n        this.cancel();\n    }\n}\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = new Delayer(defaultDelay);\n        this.throttler = new Throttler();\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    cancel() {\n        this.delayer.cancel();\n    }\n    dispose() {\n        this.delayer.dispose();\n        this.throttler.dispose();\n    }\n}\nexport function timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(new CancellationError());\n        });\n    });\n}\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler, timeout = 0, store) {\n    const timer = setTimeout(() => {\n        handler();\n        if (store) {\n            disposable.dispose();\n        }\n    }, timeout);\n    const disposable = toDisposable(() => {\n        clearTimeout(timer);\n        store?.deleteAndLeak(disposable);\n    });\n    store?.add(disposable);\n    return disposable;\n}\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nexport class TimeoutTimer {\n    constructor(runner, timeout) {\n        this._isDisposed = false;\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n        this._isDisposed = true;\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        if (this._isDisposed) {\n            throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n        }\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._isDisposed) {\n            throw new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n        }\n        if (this._token !== -1) {\n            // timer is already set\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nexport class IntervalTimer {\n    constructor() {\n        this.disposable = undefined;\n        this.isDisposed = false;\n    }\n    cancel() {\n        this.disposable?.dispose();\n        this.disposable = undefined;\n    }\n    cancelAndSet(runner, interval, context = globalThis) {\n        if (this.isDisposed) {\n            throw new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n        }\n        this.cancel();\n        const handle = context.setInterval(() => {\n            runner();\n        }, interval);\n        this.disposable = toDisposable(() => {\n            context.clearInterval(handle);\n            this.disposable = undefined;\n        });\n    }\n    dispose() {\n        this.cancel();\n        this.isDisposed = true;\n    }\n}\nexport class RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    /**\n     * Dispose RunOnceScheduler\n     */\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    /**\n     * Cancel current scheduled runner (if any).\n     */\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    /**\n     * Cancel previous runner (if any) & schedule a new runner.\n     */\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    /**\n     * Returns true if scheduled.\n     */\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        this.runner?.();\n    }\n}\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle;\nexport let _runWhenIdle;\n(function () {\n    if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n        _runWhenIdle = (_targetWindow, runner) => {\n            setTimeout0(() => {\n                if (disposed) {\n                    return;\n                }\n                const end = Date.now() + 15; // one frame at 64fps\n                const deadline = {\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                };\n                runner(Object.freeze(deadline));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                }\n            };\n        };\n    }\n    else {\n        _runWhenIdle = (targetWindow, runner, timeout) => {\n            const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    targetWindow.cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n    runWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\nexport class AbstractIdleValue {\n    constructor(targetWindow, executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = _runWhenIdle(targetWindow, () => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue extends AbstractIdleValue {\n    constructor(executor) {\n        super(globalThis, executor);\n    }\n}\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise {\n    get isRejected() {\n        return this.outcome?.outcome === 1 /* DeferredOutcome.Rejected */;\n    }\n    get isSettled() {\n        return !!this.outcome;\n    }\n    constructor() {\n        this.p = new Promise((c, e) => {\n            this.completeCallback = c;\n            this.errorCallback = e;\n        });\n    }\n    complete(value) {\n        return new Promise(resolve => {\n            this.completeCallback(value);\n            this.outcome = { outcome: 0 /* DeferredOutcome.Resolved */, value };\n            resolve();\n        });\n    }\n    error(err) {\n        return new Promise(resolve => {\n            this.errorCallback(err);\n            this.outcome = { outcome: 1 /* DeferredOutcome.Rejected */, value: err };\n            resolve();\n        });\n    }\n    cancel() {\n        return this.error(new CancellationError());\n    }\n}\n//#endregion\n//#region Promises\nexport var Promises;\n(function (Promises) {\n    /**\n     * A drop-in replacement for `Promise.all` with the only difference\n     * that the method awaits every promise to either fulfill or reject.\n     *\n     * Similar to `Promise.all`, only the first error will be returned\n     * if any.\n     */\n    async function settled(promises) {\n        let firstError = undefined;\n        const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n            if (!firstError) {\n                firstError = error;\n            }\n            return undefined; // do not rethrow so that other promises can settle\n        })));\n        if (typeof firstError !== 'undefined') {\n            throw firstError;\n        }\n        return result; // cast is needed and protected by the `throw` above\n    }\n    Promises.settled = settled;\n    /**\n     * A helper to create a new `Promise<T>` with a body that is a promise\n     * itself. By default, an error that raises from the async body will\n     * end up as a unhandled rejection, so this utility properly awaits the\n     * body and rejects the promise as a normal promise does without async\n     * body.\n     *\n     * This method should only be used in rare cases where otherwise `async`\n     * cannot be used (e.g. when callbacks are involved that require this).\n     */\n    function withAsyncBody(bodyFn) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            try {\n                await bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject {\n    static fromArray(items) {\n        return new AsyncIterableObject((writer) => {\n            writer.emitMany(items);\n        });\n    }\n    static fromPromise(promise) {\n        return new AsyncIterableObject(async (emitter) => {\n            emitter.emitMany(await promise);\n        });\n    }\n    static fromPromises(promises) {\n        return new AsyncIterableObject(async (emitter) => {\n            await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n        });\n    }\n    static merge(iterables) {\n        return new AsyncIterableObject(async (emitter) => {\n            await Promise.all(iterables.map(async (iterable) => {\n                for await (const item of iterable) {\n                    emitter.emitOne(item);\n                }\n            }));\n        });\n    }\n    static { this.EMPTY = AsyncIterableObject.fromArray([]); }\n    constructor(executor, onReturn) {\n        this._state = 0 /* AsyncIterableSourceState.Initial */;\n        this._results = [];\n        this._error = null;\n        this._onReturn = onReturn;\n        this._onStateChanged = new Emitter();\n        queueMicrotask(async () => {\n            const writer = {\n                emitOne: (item) => this.emitOne(item),\n                emitMany: (items) => this.emitMany(items),\n                reject: (error) => this.reject(error)\n            };\n            try {\n                await Promise.resolve(executor(writer));\n                this.resolve();\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            finally {\n                writer.emitOne = undefined;\n                writer.emitMany = undefined;\n                writer.reject = undefined;\n            }\n        });\n    }\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next: async () => {\n                do {\n                    if (this._state === 2 /* AsyncIterableSourceState.DoneError */) {\n                        throw this._error;\n                    }\n                    if (i < this._results.length) {\n                        return { done: false, value: this._results[i++] };\n                    }\n                    if (this._state === 1 /* AsyncIterableSourceState.DoneOK */) {\n                        return { done: true, value: undefined };\n                    }\n                    await Event.toPromise(this._onStateChanged.event);\n                } while (true);\n            },\n            return: async () => {\n                this._onReturn?.();\n                return { done: true, value: undefined };\n            }\n        };\n    }\n    static map(iterable, mapFn) {\n        return new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                emitter.emitOne(mapFn(item));\n            }\n        });\n    }\n    map(mapFn) {\n        return AsyncIterableObject.map(this, mapFn);\n    }\n    static filter(iterable, filterFn) {\n        return new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                if (filterFn(item)) {\n                    emitter.emitOne(item);\n                }\n            }\n        });\n    }\n    filter(filterFn) {\n        return AsyncIterableObject.filter(this, filterFn);\n    }\n    static coalesce(iterable) {\n        return AsyncIterableObject.filter(iterable, item => !!item);\n    }\n    coalesce() {\n        return AsyncIterableObject.coalesce(this);\n    }\n    static async toPromise(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return result;\n    }\n    toPromise() {\n        return AsyncIterableObject.toPromise(this);\n    }\n    /**\n     * The value will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitOne(value) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results.push(value);\n        this._onStateChanged.fire();\n    }\n    /**\n     * The values will be appended at the end.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    emitMany(values) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        // it is important to add new values at the end,\n        // as we may have iterators already running on the array\n        this._results = this._results.concat(values);\n        this._onStateChanged.fire();\n    }\n    /**\n     * Calling `resolve()` will mark the result array as complete.\n     *\n     * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    resolve() {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        this._state = 1 /* AsyncIterableSourceState.DoneOK */;\n        this._onStateChanged.fire();\n    }\n    /**\n     * Writing an error will permanently invalidate this iterable.\n     * The current users will receive an error thrown, as will all future users.\n     *\n     * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n     */\n    reject(error) {\n        if (this._state !== 0 /* AsyncIterableSourceState.Initial */) {\n            return;\n        }\n        this._state = 2 /* AsyncIterableSourceState.DoneError */;\n        this._error = error;\n        this._onStateChanged.fire();\n    }\n}\nexport class CancelableAsyncIterableObject extends AsyncIterableObject {\n    constructor(_source, executor) {\n        super(executor);\n        this._source = _source;\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nexport function createCancelableAsyncIterable(callback) {\n    const source = new CancellationTokenSource();\n    const innerIterable = callback(source.token);\n    return new CancelableAsyncIterableObject(source, async (emitter) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(new CancellationError());\n        });\n        try {\n            for await (const item of innerIterable) {\n                if (source.token.isCancellationRequested) {\n                    // canceled in the meantime\n                    return;\n                }\n                emitter.emitOne(item);\n            }\n            subscription.dispose();\n            source.dispose();\n        }\n        catch (err) {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(err);\n        }\n    });\n}\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}